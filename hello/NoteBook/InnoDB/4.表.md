# 第4章 表

------

[TOC]

------

## 1. 索引组织表

​		在InnoDB存储引擎中,表都是根据主键顺序组织存放的,这种存储方式的表称为索引组织表.

​		在InnoDB存储引擎中,每张表都有个主键,如果在创建表的时候没有显式的定义出主键会按照下面的方式选择或者创建一个主键字段:

-   如果有非空的唯一索引,选择这个字段作为主键字段(如果有多个,按照定义索引的顺序选择第一个字段)
-   如果不符合第一条,自动创建一个6字节大小的指针.

## 2. InnoDB逻辑存储结构

​		从InnoDB存储引擎的逻辑存储结构看,所有数据都被逻辑地存放在一个空间中,称之为表空间.表空间又由段(segment),区(extent),页(page,默认为16K)组成.

### (1). 表空间

​		表空间可以看做是InnoDB存储引擎逻辑结构的最高层,所有的数据都存放在表空间中.如果用户启用了参数innodb_file_per_table,则每张表都可以有一个独立的表空间.

​		但要注意的是,每张表的独立表空间只存放数据,索引和插入缓冲Bitmap页,其他类的数据(undo回滚信息,插入缓冲索引页,系统事务信息,二次写缓冲等等)还是存放在共享表空间的.那么意味着,就算开启了innodb_file_per_table参数,共享表空间还是会不断的增大.

​		在共享表空间中的空间如果失效(如被覆盖掉的undo信息),并不会立即回收这些内存,而是标记为可用空间,供下次使用.

### (2). 段

​		表空间是又一个一个段组成的,常见的段有数据段,索引段,回滚段等等.

​		InnoDB存储引擎是索引组织的,因此数据即索引,索引即数据.那么数据段即为B+树的叶子节点,索引段即为B+数的非叶子节点.回滚段较为特殊,暂不介绍.

​		才InnoDB存储引擎中,对段的管理都是由引擎自身所完成.

### (3). 区

​		区是由连续页组成的空间,在任何情况下每个区的大小都为1MB,为了保证区中页的完整性,InnoDB存储引擎一次性会从磁盘申请4~5个区.在默认情况下,InnoDB存储引擎页的大小为16KB,即一个区中有64个连续的页.

​		但是这64个连续的页并不是在申请完区空间后就得到的.InnoDB存储引擎在每一个区开始使用时会使用32个页大小的碎片页来存放数据,这些页使用完时候才会一次性申请64个连续页.这样的目的是对于一些小表,或者undo这类的段,可以在开始时申请较少的空间,节省磁盘容量的开销.

### (4). 页

​		页是InnoDB磁盘管理的最小单位,默认每个页的大小为16KB.从InnoDB 1.2.x版本开始,可以通过innodb_page_size将页的大小设置为4K,8K,16K.

常见的页类型有:

-   数据页(B-tree Node)
-   undo页(undo Log Page)
-   系统页(System Page)
-   事务数据页(Transaction system Page)
-   插入缓冲位图页(Insert Buffer Bitmap)
-   插入缓冲空闲列表页(Insert Buffer Free List)
-   未压缩的二进制大对象页(Uncompressed BLOB Page)
-   压缩的二进制大对象页(compressed BLOB Page)

### (5). 行

​		InnoDB存储引擎是面向列的 ,也就是说数据是按行进行存放的.每个页存放的行记录也是有硬性定义的,最多允许存放7992行数据(16KB/2-200).

## 3. InnoDB行记录格式

​		InnoDB存储引擎和大多数数据库一样,记录是以行的形式存储的.在InnoDB 1.0.x版本之前,InnoDB存储引擎提供了Compact和Redundant两中格式来存放行记录数据.在MySQL 5.1版本中,默认设置为Compact版本.

### (1). Compact行记录格式

​		Compact行记录实在MySQL 5.0中引入的,其设计目的是高效的存储数据.一个页中存放的行数据越多,其性能就越高.

​		Compact行记录格式由变长字段长度列表,NULL标志位,记录头信息,列数据1,列数据2.....组成.

​		其中变长字段长度列表是按照列的逆序排列的,有若干个1或者2字节的二进制数组成(1字节代表225的长度,2字节则为65535).变长字段长度列表之后的第二个部分是NULL标志为,改为只是了该行数据是否有NULL值,以二进制的形式展示.接下来是记录头信息,固定站5字节,含义见下表:

| 名称         | 大小 | 描述                                                         |
| ------------ | ---- | ------------------------------------------------------------ |
| ()           | 1    | 未知                                                         |
| ()           | 1    | 未知                                                         |
| delete_flag  | 1    | 该行是否被删除                                               |
| min_rec_flag | 1    | 为1则代表该记录是预先被定义为最小的记录                      |
| n_owned      | 4    | 该记录拥有的记录数                                           |
| heap_no      | 13   | 索引堆中该条记录的排序记录                                   |
| record_type  | 3    | 记录类型:000表示普通,001表示B+数节点指针,010表示Infimum,011表示Supermum,1xx表示保留 |
| next_record  | 16   | 页中下一条记录的相对位置                                     |
| Total        | 40   |                                                              |

​		最后的部分就是存储每个列的数据,NULL不占该部分的任何空间.

​		每行数据除了用户定义的列外,还有两个隐藏列,事务ID列(6字节)和回滚指针列(7字节).如果InnoDB表没有定义主键,每行还会增加一个rowid列.

### (2). Redundant行记录格式

​		Redundant是MySQL 5.0之前InnoDB的行记录存储方式,不同于Compact方式,首部是一个字段长度偏移列表,同样是逆序,然后是记录头信息,紧跟着列数据1,列数据2......

| 名称            | 大小 | 描述                                     |
| --------------- | ---- | ---------------------------------------- |
| ()              | 1    | 未知                                     |
| ()              | 1    | 未知                                     |
| delete_flag     | 1    | 该行是否已经被删除                       |
| min_rec_flag    | 1    | 如果为1,则该记录是预先被定义为最小的记录 |
| n_owned         | 4    | 该记录拥有的记录数                       |
| heap_no         | 13   | 索引堆中该条记录的索引号                 |
| n_fields        | 10   | 记录中列的数量                           |
| 1byte_offs_flag | 1    | 偏移列表为1字节还是2字节                 |
| next_record     | 16   | 页中下一条记录的相对位置                 |
| Total           | 48   |                                          |

### (3). 行溢出数据

​		InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页之外,一般为BLOB,LOB这种大对象列类型会这样存储.但是需要注意的是,BLOB也可以不将数据放在溢出页面,VARCHAR也可能会存在溢出页面之中.

​		VARCHAR类型最大支持65535字节,所以对于不同的编码格式,存储的数据长度是不一致的.此外这个长度是对于一行中的所有列VARCHAR总长度和,如果这个总长度超出了65535字节,就发生了溢出,会将数据存放在Uncompress BLOB页中.

​		InnoDB存储引擎表是索引组织的,即B+Tree的结构,这样每个页中至少要存放两条数据才有意义,如果一行的大小不允许同一页中在存放下一行数据,那么这一行数据就会被存放入溢出页中.

​		对于TEXT和BLOB类型的数据,与VARCHAR一样.

​		大多数情况下,BLOB类型的数据都很大,都会溢出的,数据数据都是保存在BLOB页中的,数据页只保存前768字节.

### (4). Compressed和Dynamic行记录格式

​		InnoDB 1.0.x版本开始引入了新的文件格式,成为Barracuda文件格式,有两种行记录格式:Compressed和Dynamic.这两种新的记录格式对于存放BLOB中的数据采用了完全的行溢出方式.

​		除此之外,Compressed行记录格式的另一个功能是存储在其中的行数据会以zlib的算法进行压缩.

### (5). CHAR的行结构存储

​		从MySQL 4.1版本开始,CHR(N)中的N指的是字符的长度,而不是存储数据所占字节长度.也就是说不同的字符集下,CHAR类型存储的不是定长数据.

## 4. InnoDB数据页结构

​		页是InnoDB存储引擎管理数据库的磁盘最小单位,InnoDB数据页由一下7部分组成:

-   File Header(文件头)
-   Page Header(页头)
-   Infimun和Supermum Records
-   User Records(行记录)
-   Free Space(空闲空间)
-   Page Directory(页目录)
-   File Trailer(文件结尾信息)

### (1). File Header

​		File Header用来记录页的一些头信息,由以下8部分组成共38字节.

File Header组成部分:

| 名称                             | 大小(字节) | 说明                                                 |
| -------------------------------- | ---------- | ---------------------------------------------------- |
| FIL_PAGE_SPACE_OR_CHKSUM         | 4          | MySQL 4.0.14之前该值为0,之后代表该页的checksum值     |
| FIL_PAGE_OFFSET                  | 4          | 表空间中页的偏移值.                                  |
| FIL_PAGE_PREV                    | 4          | 当前页的上一页(B+数决定叶子节点必定是双向链表)       |
| FIL_PAGE_NEXT                    | 4          | 当前页的下一页                                       |
| FIL_PAGE_LSN                     | 8          | 代表该页最后被修改的日志位置LSN(Log Sequence number) |
| FIL_PAGE_TYPE                    | 2          | InnoDB存储引擎页的类型(0x45BF代表数据页)             |
| FIL_PAGE_FILE_FLUSH_LSN          | 8          | 在系统表空间的页中定义,代表文件至少被更新到了该LSN值 |
| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID | 4          | 从MySQL 4.1开始代表该页属于那个表空间                |

InnoDB存储引擎中页的类型:

| 名称                    | 十六进制表示 | 解释                  |
| ----------------------- | ------------ | --------------------- |
| FIL_PAGE_INDEX          | 0x45BF       | B+数叶节点            |
| FIL_PAGE_UNDO_LOG       | 0x0002       | Undo log页            |
| FIL_PAGE_INODE          | 0x0003       | 索引节点              |
| FIL_PAGE_IBUF_FREE_LIST | 0x0004       | Insert Buffer空闲列表 |
| FIL_PAGE_TYPE_ALLOCATED | 0x0000       | 该页为最新分配        |
| FIL_PAGE_IBUF_BITMAP    | 0x0005       | Insert Buffer位图     |
| FIL_PAGE_TYPE_SYS       | 0x0006       | 系统页                |
| FIL_PAGE_TYPE_TRX_SYS   | 0x0007       | 事物系统数据          |
| FIL_PAGE_TYPE_FSP_HDR   | 0x0008       | File Space Header     |
| FIL_PAGE_TYPE_XDES      | 0x0009       | 拓展描述页            |
| FIL_PAGE_TYPE_BLOB      | 0x000A       | BLOB页                |

### (2). Page Header

​		该部分用来记录数据页的状态信息.由14部分组成,共56字节.

| 名称              | 大小(字节) | 说明                                                         |
| ----------------- | ---------- | ------------------------------------------------------------ |
| PAGE_N_DIR_SLOTS  | 2          | 在Page Directory(页目录)中的Slot(槽)数                       |
| PAGE_HEAP_TOP     | 2          | 堆中第一个记录的指针,记录在页中的数据以堆的形式存放          |
| PAGE_N_HEAP       | 2          | 堆中的记录数                                                 |
| PAGE_FREE         | 2          | 指向可重用空间的首指针                                       |
| PAGE_GARBAGE      | 2          | 已删除记录的字节数                                           |
| PAGE_LAST_INSERT  | 2          | 最后插入记录的位置                                           |
| PAGE_DIRECTION    | 2          | 最后插入的方向(0x01,ox02,0x03,0x04,0x05)                     |
| PAGE_N_DIRECTION  | 2          | 一个方向上连续插入记录的数量                                 |
| PAGE_N_RECS       | 2          | 该页中记录的数量                                             |
| PAGE_MAX_TRX_ID   | 8          | 就当前页的最大事务ID                                         |
| PAGE_LEVEL        | 2          | 当前页在索引数中的位置,0x00代表叶节点                        |
| PAGE_INDEX_ID     | 8          | 索引ID                                                       |
| PAGE_BTR_SEG_LEAF | 10         | B+树数据页非叶节点所在段的segment header.(仅在B+数的root页中被定义) |
| PAGE_BTR_SEG_TOP  | 10         | B+树数据页所在段的segment header.(仅在B+数的root页中被定义)  |

### (3). Infimum和Supremum Record

​		每个数据页中有两个虚拟的行记录,用来限定记录的边界.Infimum用来记录比页中任何主键值都要小的值,Supermum指比任何可能大的值还要大的值.这两个值在页创立时建立,任何情况下不会被删除.

### (4). User Record和Free Space

​		User Record指数据存储行记录的内容.

​		Free Space值空闲空间,也是个链表数据结构.一条记录被删除后会被加入到空闲链表中.

### (5). Page Directory

​		页目录,其中存放了记录的**<u>相对</u>**位置,有时候这些记录指针被称为Slots(槽).在InnoDB中并不是每个记录拥有一个槽,InnoDB存储引擎的槽是一个稀疏目录,一个槽中可能包含多个记录.

### (6). File Trailer

​		为了检测页是否已经完整的写入磁盘,设置了File Trailer部分.

​		该部分只有一个FIL_PAGE_END_LSN部分,占用8字节.前4字节代表该页的checksum值,最后4字节和File Header中的FIL_PAGE_LSN相同.这两个值用于与File Header中的FIL_PAGE_SPACE_OR_CHKSUM和FIL_PAGE_LSN进行比较,依次来确保页的完整性.

​		默认情况下,每次从磁盘读取一个页就会检查依次该页的完整性,就是通过检查File Trailer部分进行检测.

## 5. Named File Formats机制

​		目的是解决不同版本下页结构兼容性问题.

​		InnoDB存储引擎不同版本之间新的文件格式总是包含于之前版本的页格式.

## 6. 约束

### (1). 数据完整性

​		关系型数据库和文件系统的一个不同点就是关系数据库本身能保证数据的完整性,不需要应用程序的空值,而文件系统一般需要在程序端进行控制.

数据完整性有一下三种形式:

1.  实体完整性保证表中有一个主键
1.  域完整性保证每列数据的值满足特定的条件,实现:
    1.  选择合适的数据类型
    1.  外键约束
    1.  触发器
    1.  default约束(默认值)
1.  参照完整性保证两张表之间的关系(外键,触发器)

### (2). 约束的创建和查找

约束的创建可以使用一下两种方式:

1.  建立表时进行约束的定义
1.  利用alter table命令创建约束

对于Unique Key(唯一索引)还能通过create unique index命令创建.

```SQL
create table 库名.表名(
    字段名1 类型[(宽度) 约束条件],
    字段名2 类型[(宽度) 约束条件],
    字段名3 类型[(宽度) 约束条件]
);

// 常见约束
primary key (PK)      #标识该字段为该表的主键，可以唯一的标识记录，主键就是不为空且唯一当然其还有加速查询的作用
foreign key (FK)      #标识该字段为该表的外键，用来建立表与表的关联关系
not null              #标识该字段不能为空
unique key (UK)       #标识该字段的值是唯一的
auto_increment        #标识该字段的值自动增长（整数类型，而且为主键）
default               #为该字段设置默认值

unsigned              #将整型设置为无符号即正数
zerofill              #不够使用0进行填充
```

### (3). 约束和索引的区别

​		当用户创建了一个唯一索引就创建了一个唯一的约束.

​		约束是一个逻辑的概念,用来保护数据的完整性,而索引是一个数据结构,既有逻辑上的概念,在数据库中还代表着物理存储的方式.

### (4). 对错误数据的约束

​		MySQL数据库允许非法的或者不正确的数据插入或更新,又或者可以在数据库内部将其转化为一个合法的值,数据库本身没有对数据的正确性进行约束.

### (5). ENUM和SET约束

​		MySQL数据库不支持传统的CHECK约束,但是通过ENUM和SET