# 第4章 表

------

[TOC]

------

## 1. 索引组织表

​		在InnoDB存储引擎中,表都是根据主键顺序组织存放的,这种存储方式的表称为索引组织表.

​		在InnoDB存储引擎中,每张表都有个主键,如果在创建表的时候没有显式的定义出主键会按照下面的方式选择或者创建一个主键字段:

-   如果有非空的唯一索引,选择这个字段作为主键字段(如果有多个,按照定义索引的顺序选择第一个字段)
-   如果不符合第一条,自动创建一个6字节大小的指针.

## 2. InnoDB逻辑存储结构

​		从InnoDB存储引擎的逻辑存储结构看,所有数据都被逻辑地存放在一个空间中,称之为表空间.表空间又由段(segment),区(extent),页(page,默认为16K)组成.

### (1). 表空间

​		表空间可以看做是InnoDB存储引擎逻辑结构的最高层,所有的数据都存放在表空间中.如果用户启用了参数innodb_file_per_table,则每张表都可以有一个独立的表空间.

​		但要注意的是,每张表的独立表空间只存放数据,索引和插入缓冲Bitmap页,其他类的数据(undo回滚信息,插入缓冲索引页,系统事务信息,二次写缓冲等等)还是存放在共享表空间的.那么意味着,就算开启了innodb_file_per_table参数,共享表空间还是会不断的增大.

​		在共享表空间中的空间如果失效(如被覆盖掉的undo信息),并不会立即回收这些内存,而是标记为可用空间,供下次使用.

### (2). 段

​		表空间是又一个一个段组成的,常见的段有数据段,索引段,回滚段等等.

​		InnoDB存储引擎是索引组织的,因此数据即索引,索引即数据.那么数据段即为B+树的叶子节点,索引段即为B+数的非叶子节点.回滚段较为特殊,暂不介绍.

​		才InnoDB存储引擎中,对段的管理都是由引擎自身所完成.

### (3). 区

​		区是由连续页组成的空间,在任何情况下每个区的大小都为1MB,为了保证区中页的完整性,InnoDB存储引擎一次性会从磁盘申请4~5个区.在默认情况下,InnoDB存储引擎页的大小为16KB,即一个区中有64个连续的页.

​		但是这64个连续的页并不是在申请完区空间后就得到的.InnoDB存储引擎在每一个区开始使用时会使用32个页大小的碎片页来存放数据,这些页使用完时候才会一次性申请64个连续页.这样的目的是对于一些小表,或者undo这类的段,可以在开始时申请较少的空间,节省磁盘容量的开销.

### (4). 页

​		页是InnoDB磁盘管理的最小单位,默认每个页的大小为16KB.从InnoDB 1.2.x版本开始,可以通过innodb_page_size将页的大小设置为4K,8K,16K.

常见的页类型有:

-   数据页(B-tree Node)
-   undo页(undo Log Page)
-   系统页(System Page)
-   事务数据页(Transaction system Page)
-   插入缓冲位图页(Insert Buffer Bitmap)
-   插入缓冲空闲列表页(Insert Buffer Free List)
-   未压缩的二进制大对象页(Uncompressed BLOB Page)
-   压缩的二进制大对象页(compressed BLOB Page)

### (5). 行

​		InnoDB存储引擎是面向列的 ,也就是说数据是按行进行存放的.每个页存放的行记录也是有硬性定义的,最多允许存放7992行数据(16KB/2-200).

## 3. InnoDB行记录格式

​		InnoDB存储引擎和大多数数据库一样,记录是以行的形式存储的.在InnoDB 1.0.x版本之前,InnoDB存储引擎提供了Compact和Redundant两中格式来存放行记录数据.在MySQL 5.1版本中,默认设置为Compact版本.

### (1). Compact行记录格式

​		Compact行记录实在MySQL 5.0中引入的,其设计目的是高效的存储数据.一个页中存放的行数据越多,其性能就越高.

​		Compact行记录格式由变长字段长度列表,NULL标志位,记录头信息,列数据1,列数据2.....组成.

​		其中变长字段长度列表是按照列的逆序排列的,有若干个1或者2字节的二进制数组成(1字节代表225的长度,2字节则为65535).变长字段长度列表之后的第二个部分是NULL标志为,改为只是了该行数据是否有NULL值,以二进制的形式展示.接下来是记录头信息,固定站5字节,含义见下表:

| 名称         | 大小 | 描述                                                         |
| ------------ | ---- | ------------------------------------------------------------ |
| ()           | 1    | 未知                                                         |
| ()           | 1    | 未知                                                         |
| delete_flag  | 1    | 该行是否被删除                                               |
| min_rec_flag | 1    | 为1则代表该记录是预先被定义为最小的记录                      |
| n_owned      | 4    | 该记录拥有的记录数                                           |
| heap_no      | 13   | 索引堆中该条记录的排序记录                                   |
| record_type  | 3    | 记录类型:000表示普通,001表示B+数节点指针,010表示Infimum,011表示Supermum,1xx表示保留 |
| next_record  | 16   | 页中下一条记录的相对位置                                     |
| Total        | 40   |                                                              |

​		最后的部分就是存储每个列的数据,NULL不占该部分的任何空间.

​		每行数据除了用户定义的列外,还有两个隐藏列,事务ID列(6字节)和回滚指针列(7字节).如果InnoDB表没有定义主键,每行还会增加一个rowid列.

### (2). Redundant行记录格式

​		Redundant是MySQL 5.0之前InnoDB的行记录存储方式,不同于Compact方式,首部是一个字段长度偏移列表,同样是逆序,然后是记录头信息,紧跟着列数据1,列数据2......

| 名称            | 大小 | 描述                                     |
| --------------- | ---- | ---------------------------------------- |
| ()              | 1    | 未知                                     |
| ()              | 1    | 未知                                     |
| delete_flag     | 1    | 该行是否已经被删除                       |
| min_rec_flag    | 1    | 如果为1,则该记录是预先被定义为最小的记录 |
| n_owned         | 4    | 该记录拥有的记录数                       |
| heap_no         | 13   | 索引堆中该条记录的索引号                 |
| n_fields        | 10   | 记录中列的数量                           |
| 1byte_offs_flag | 1    | 偏移列表为1字节还是2字节                 |
| next_record     | 16   | 页中下一条记录的相对位置                 |
| Total           | 48   |                                          |

### (3). 行溢出数据

​		InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页之外,一般为BLOB,LOB这种大对象列类型会这样存储.但是需要注意的是,BLOB也可以不将数据放在溢出页面,VARCHAR也可能会存在溢出页面之中.

​		VARCHAR类型最大支持65535字节,所以对于不同的编码格式,存储的数据长度是不一致的.此外这个长度是对于一行中的所有列VARCHAR总长度和,如果这个总长度超出了65535字节,就发生了溢出,会将数据存放在Uncompress BLOB页中.

​		InnoDB存储引擎表是索引组织的,即B+Tree的结构,这样每个页中至少要存放两条数据才有意义,如果一行的大小不允许同一页中在存放下一行数据,那么这一行数据就会被存放入溢出页中.

​		对于TEXT和BLOB类型的数据,与VARCHAR一样.

​		大多数情况下,BLOB类型的数据都很大,都会溢出的,数据数据都是保存在BLOB页中的,数据页只保存前768字节.

### (4). Compressed和Dynamic行记录格式

​		InnoDB 1.0.x版本开始引入了新的文件格式,成为Barracuda文件格式,有两种行记录格式:Compressed和Dynamic.这两种新的记录格式对于存放BLOB中的数据采用了完全的行溢出方式.

​		除此之外,Compressed行记录格式的另一个功能是存储在其中的行数据会以zlib的算法进行压缩.

### (5). CHAR的行结构存储

​		从MySQL 4.1版本开始,CHR(N)中的N指的是字符的长度,而不是存储数据所占字节长度.也就是说不同的字符集下,CHAR类型存储的不是定长数据.

## 4. InnoDB数据页结构

​		页是InnoDB存储引擎管理数据库的磁盘最小单位,InnoDB数据页由一下7部分组成:

-   File Header(文件头)
-   Page Header(页头)
-   Infimun和Supermum Records
-   User Records(行记录)
-   Free Space(空闲空间)
-   Page Directory(页目录)
-   File Trailer(文件结尾信息)