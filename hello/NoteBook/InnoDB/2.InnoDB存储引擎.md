# 第2章 InnoDB存储引擎

------

[TOC]

------

​		InnoDB是事务安全的MySQL存储引擎,设计上采用了类似与Oracle数据库的架构.通常来说,InnoDB存储引擎是OLTP应用中核心表的首选存储引擎.

## 1. InnoDB存储引擎概述

​		该存储引擎是第一个完整支持ACID事务的MySQL存储引擎,其特点是行锁设计,支持MVCC,支持外键,提供一致性非读定锁,同事被设计用来最有效地利用以及使用内存和CPU.

## 2. InnoDB存储引擎的版本

1.  老版本InnoDB:支持ACID,行锁,MVCC
1.  InnoDB 1.0.x:增加了compress和dynamic页格式
1.  InnoDB 1.1.x:增加了Linux AIO,多回滚段
1.  InnoDB 1.2.x:增加了全文索引支持,在线索引添加

## 3. InnoDB体系架构

​		InnoDB存储引擎内部有多个内存块,可疑人物这些内存块组成了一个大的内存池

![img](https://upload-images.jianshu.io/upload_images/5304392-451053fb97782ac9.PNG?imageMogr2/auto-orient/strip|imageView2/2/w/766/format/webp)

​		后台线程:主要作用是刷新内存池中的数据,保证缓冲池中的内存缓存是最近的数据,此外将已修改的数据刷新到磁盘文件,同时保证数据库发生异常的情况下InnoDB能恢复带正常的运行状态.

### (1). 后台线程

​		InnoDB存储引擎是多线程的模型,因此其后台有多个不同的后台线程,负责处理不同的任务.

#### 1). Master Thread

​		主要讲缓冲池中的数据异步刷新到磁盘,保证数据的一致性.

#### 2). IO Thread

​		InnoDB存储引擎中大量使用了AIO来处理写IO请求,这样可以极大提高数据库的性能,而IO Thread的工作只要是负责这些IO请求的回调处理.

#### 3). Purge Thread

​		回收已经使用并分配的undo页.

​		(undo:在操作数据前,现将数据备份到一个地方然后修改,这个备份叫undo log)

#### 4). Page Cleaner Thread

​		葬夜的刷新操作都放入到单独的线程来完成的.

### (2). 内存

#### 1). 缓冲池

​		InnoDB存储引擎是基于磁盘存储的,并将其中的记录按照页的方式进行管理.因此可将其视为基于磁盘的数据库系统.

​		缓冲池简单来说就是一块内存区域,通过内存的速度来弥补磁盘速度较慢对数据库性能的影响.在数据库中进行读取页的操作,首先将从磁盘中读到的页放在缓冲池中.在下一次在读取相同页时,首先判断该页是否在缓冲池中,如果在,称该页在缓冲池中被命中,直接读取该页,否则,读取磁盘上的页.

​		对数据库中页的修改操作,则首先修改在缓冲池中的页,然后再以一定的频率刷新到磁盘上.

​		缓冲池的大小直接影响着数据库的整体性能.

​		**<u>具体来看,缓冲池中缓存的页类型有:索引页,数据页,undo页,插入缓冲,自适应哈希索引,InnoDB存储的锁信息,数据字典等.</u>**

​		从InnoDB 1.0.x版本开始,允许有多个缓冲池实例.每个页根据哈希值平均分配到不同的缓冲池实例中.

#### 2). LRU list,Free list和Flush list

​		通常来讲,数据库中的缓冲池是通过LRU(Latest Recent Used,最近最少使用)算法来进行管理的.及最频繁使用的页在LRU列表的前端,最少使用的页在LRU列表的尾端.当缓冲池不能存放新的页时,释放尾端的页.

​		缓冲池中页的默认大小为16K.

​		InnoDB存储引擎还对传统的LRU算法进行了优化,加入了midpoint位置.

​		新读取的页,虽然是最新访问的页,但是并不一定是经常活跃的页,直接放入列表前端有些不妥.InnoDB存储引擎的优化为将新页插入到设定好的midpoint位置.默认为列表长度的前5/8处.InnoDB存储引擎将midpoint前的表成为new列表,之后的页称之为old列表.(还有一个原因是,如果进行的是扫描操作,那么所有的页都会进入LRU列表一次,插入前端会刷新整个LRU列表)

​		InnoDB存储引擎还提供了innodb_old_blocks_time参数,用于设定读取页后多久将该页放入LRU列表的热端.

​		刚启动数据库时,LRU列表是空的,所有的页都存放在Free列表中.当需要从缓冲池分配页时,首先从Free列表中查找是否有可用的空闲页,如果有将该空闲页从Free列表中删除,并插入到LRU列表中.否则从LRU列表尾端淘汰一个页,重新分配内存.

​		LRU列表中的页被修改后,被称为脏页.而Flush列表中的页即为脏页.需要注意的是,脏页既存在于Flush列表中,页存在于LRU列表中.

​		LRU列表用于管理缓冲池中页的可用性,Flush列表用来管理将页刷新会磁盘,二者互不影响.

#### 3). 重做日志缓冲

​		InnoDB存储引擎首先将重做日志先放入到这个缓冲区,然后按一定频率将其刷新到重做日志文件,这个缓冲一般不会设置的很大,因为一般情况下每一秒都会有刷新操作.默认大小为8MB.

#### 4). 额外的缓冲池

​		在InnoDB存储引擎中,堆内存的管理是通过一种成为内存堆的方式进行的,在对一些数据结构本身的内存进行分配时,需要从额外的内存池中进行申请,当该区域的内存不够时,会从缓冲池中进行申请.

## 4. Checkpoint技术

​		为了避免发生数据丢失的问题,当前的事务数据库系统普遍都采用了Write Ahead Log策略,即当事务提交时,先重写日志,再修改页.

​		那么试想,是不是可以只保存日志,完全通过日志来恢复整个数据库系统中的数据带宕机发生的时刻,这需要两个前提条件:

1.  缓冲池可以缓存数据库中所有数据
1.  重做日志可以无线增大

​		如果上面两个条件都满足,还需要考虑宕机后数据恢复的时间.

​		所以,出现了Checkpoint技术,当数据库发生宕机时,不需要重做所有的日志,因为Checkpoint之前的页都已经刷新回磁盘了.当缓冲池不够用时,根据LRU算法会溢出最近最少使用的页,如果此页为脏页,会强制执行Checkpoint,将脏页刷新回磁盘.

​		对于InnoDB存储引擎而言,是通过LSN来标记版本的.而LSN是8字节的数据,其单位是字节.

在InnoDB存储引擎内部,有两种Checkpoint:

-   Sharp Checkpoint:刷新全部脏页
-   Fuzzy Checkpoint:在InnoDB内部使用,只刷新部分脏页