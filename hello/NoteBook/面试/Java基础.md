# Java SE面试中常见问题总结

------

[TOC]

------

## 1. Java面向对象

### (1). 封装

​		核心思想就是“隐藏细节”、“数据安全”：将对象不需要让外界访问的成员变量和方法私有化，只提供符合开发者意愿的公有方法来访问这些数据和逻辑，保证了数据的安全和程序的稳定。

​		使用 `private` 修饰符把成员变量设置为私有，防止外部程序直接随意调用或修改成员变量，然后对外提供 `public` 的 `set` 和 `get` 方法按照开发者的意愿（可以编写一些业务逻辑代码，虽然很少这样做）设置和获取成员变量的值。

### (2). 继承

​		用来提高了程序的复用性、扩展性

​		在实际开发中,应该是先有子类,然后从中抽象封装出父类

​		使用extends关键字实现

​		Java只允许单继承

​		父类中public和protected修饰的成员变量和方法可以被子类集成,构造方法不能被继承,但可以在子类中使用super()调用.子类中可以降低提高级别而不能降低.

​		state修饰的变量或者方法属于类,不能被继承,但是子类可以直接调用

#### 1). 方法重写

​		方法重写针对于实例方法.

​		方法名和参数必须一致,访问修饰可以提高.(如果有必要可以才上方添加@Override注解自动检查)

​		返回值可以不一样,但是只能是子类.

​		抛出异常必须是父类该方法抛出异常的子集

​		对于类方法(static,静态),在子类中重写是进行隐藏(与重载的区别是如果向上进行转型,那么执行的还是父类的方法)

#### 2). 类实例化的过程

1.  读取class文件,加载到内存,如果有父类,也会加载父类(==加载和验证==)
1.  堆内存分配空间(==准备==,会赋初值为默认值)
1.  执行父类,子类静态代码块(在这一步之前进行了==解析==过程,将符号引用转化为直接引用)
1.  对对象属性进行默认初始化(显示赋值的)
1.  调用构造方法
    1.  先调用父类构造方法初始化父类数据
    1.  显示的执行子类的构造代码块(与静态代码块的区别在于不加static)
    1.  执行子类构造方法中的代码进行初始化
1.  将地址赋给引用(外层new关键字那里)

### (3). 多态

​		同一个行为具有多个不同表现形式.

​		==同一个接口使用不同的实例对象而执行不同的操作.==

​		Java中有两种引用类型:编译时类型和运行时类型.编译时类型由引用决定,运行时类型由实例对象的类型决定.

条件:

-   继承
-   重写
-   父类引用指向子类对象

​		在编译时会先判断父类中有没有此方法,如果没有,则编译错误.如果有,再去调用子类中的同名方法(要么继承下去,要么被重写,只有被重写才能体现出多态性)

## 2. 访问权限修饰关键字

|           | 本类 | 本包 | 子类 | 外部包 |
| --------- | ---- | ---- | ---- | ------ |
| public    | √    | √    | √    | √      |
| protected | √    | √    | √    | ×      |
| default   | √    | √    | ×    | ×      |
| private   | √    | ×    | ×    | ×      |

​		访问权限的控制是在编译层的,通过反射还是可以访问私有成员的

## 3. Java中的异常

### (1). 异常体系

![img](https://upload-images.jianshu.io/upload_images/5982616-4ab25f2cfc5ca7b8.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/600/format/webp)

-   Throwable:所有错误或者异常的超类,这个类或者其子类才能被throw抛出,才能作为catch中的参数类型
    -   Error:不应该捕获的严重类型,出现就应该退出程序
        -   VirtulMachineError:虚拟机错误(硬件错误，还是内存不够等等)
        -   AWTError:AWT是Java用户界面和绘制图形图像的包,这个错误多是GUI中产生的
    -   Exception:通常讲的异常,==受检查异常==,值程序可以处理的异常
        -   RuntimeException:==运行时异常==,可以不进行处理也可以加上try-catch或者throws
            -   空指针,数组越界,类型转换,算数错误,非法参数等等
        -   IOException:输入输出异常,这里代表性的泛指非运行时异常(又称可检查异常),必须要显示的加上try-catch或者throws,否则编译不通过
        -   等等,没有列举出全部

### (2). throws和throw关键字

​		throws关键字用于在方法后面声明方法内部可能会抛出的异常.

​		throw用于手动的抛出异常(通常在try-catch中会有一些处理后再向外层抛出,具体使用与业务逻辑有关)

### (3). finally关键字

​		无论是否发生异常,finally代码块中的代码都会被执行

>   关于return和finally的顺序:
>
>   return语句其实是先将后面的变量从局部变量区放入操作数栈顶,然后执行return,返回操作数栈顶的值
>
>   finally代码块中的代码执行在这两个过程之间.也就是说,如果finally代码块中没有出现return语句,是不会影响方法的返回值的.如果有,那么操作数栈顶的值会被替换,会改变方法的返回值.

## 4. Synchronized详解

### (1). Synchronized使用

#### 1). 对象锁(同步代码块)

```java
synchronized (object) {
	// 临界区代码
}
```

​		不同线程访问同一个对象的对象锁,只能有一个线程成功进入,其他线程阻塞在代码块外面.当该线程退出代码块时,其他的线程进行CPU的竞争(就绪态),成功竞争到CPU的线程获取锁.

#### 2). 方法锁(同步方法)

```java
public synchronized method(){
    // 整个方法内部都是临界区
}
```

​		不同线程不能同时进入此方法,锁对象为this,所以多个线程调用==同一个对象的不同同步方法==也会进行同步

#### 3). 类锁

```java
public MyClass{
    public synchronized static void method(){}
}
```

​		不同的线程不能同时进入这个类的这个静态方法.使用当前类的类对象==MyClass.class为锁==,所以其他线程只要调用这个类其中的任意一个静态同步方法,都会被阻塞.

### (2). Synchronized原理

#### 1). Java对象模型

​		每一个Java类在被JVM加载的时候,JVM都会给这个类创建一个instanceKlass保存在方法区,在JVM层用来表示该Java类.使用new创建一个对象的时候,JVM会创建一个instanceOopDesc对象,这个对象中包含了对象头和实例数据(还会有填充数据来保证每个对象的内存都是8字节的整数倍)

​		对象头包含两部分:Mark Word(运行时数据,哈希码,GC分代年龄,锁状态标志,等等)和Klass Point(只想的是对象所属类的instanceKlass).

​		对象的实例（instantOopDesc)保存在堆上，对象的元数据（instantKlass）保存在方法区，对象的引用保存在栈上。

#### 2). 监视锁Monitor

​		每一个Object对象中都内置了一个Monitor对象.(对象头中Mark Word中的LockWord指向的是Monitor对象的起始地址)

​		Monitor相当于许可证,拿到Monitor可以进行操作,没拿到需要等待.

Monitor中有几个关键属性:

-   _owner:指向持有Monitor对象的线程
-   _WaitSet:存放在该Monitor上处于wait状态的线程队列(obj.wait())
-   _EntryList:存放处于等待锁block状态的线程队列
-   _recursions:锁的可重入次数
-   _count:用来记录当前占有锁的线程的重入次数

一些操作:

-   线程T等待获取锁(同步代码块外等待):_EntryList中加入T
-   线程T获取对象锁(进入代码块):\_EntryList移除T,\_Owner置为T,计数器\_count+1
-   线程T获取对象锁之后调用了wait()方法:在之前的基础上给\_WaitSet中加入T

#### 3). Synchronized底层

##### 1>. 同步代码块

-   monitorenter指令插入到同步代码块的开始位置
-   monitorexit指令插入到同步代码块的结束位置

​		JVM保证这两个指令是一一对应的.

​		当线程执行到monitorenter时,会尝试获取该对象所对应的monitor的所有权.

##### 2>. 同步(静态)方法

​		synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令.

​		在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在==Class文件的方法表中将该方法的access_flags字段中的synchronized标志置为1==，表示该方法是同步方法并==使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象==。

### (3). 锁优化

#### 1). 重量级锁

​		synchronized本质依赖监视器锁monitor实现,而monitor的本质是依赖于底层操作系统的Mutex Lock实现,要进行线程之间的切换需要从用户态转换成内核态,成本非常高.