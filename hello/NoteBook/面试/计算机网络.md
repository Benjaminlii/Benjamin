# 计算机网络面试中常见问题总结

------

[TOC]

------

## 1. 一个网络请求的完整过程

1.  浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器==搜索自身(浏览器)的DNS缓存==、==搜索操作系统的DNS缓存==、==读取本地的Host文件==和==向本地DNS服务器(一般是设定好的服务商提供的
    服务器DNS)进行查询==等。如果要查询的域名曾经解析过,有缓存，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；
    1.  ==递归查询==是指客户端要求本地服务器一定返回一个结果,只发出一次请求.本地服务器查找本地缓存后,查找"根",交由"根"去完成这件事
    1.  ==迭代查询==是指DNS服务器会向自己下属的所有服务器多次发送请求.
1.  浏览器获得域名对应的IP地址(实际上还需要==ARP==协议获得目标服务器的MAC地址,根据MAC地址去传输)以后，浏览器向服务器请求==建立链接==，发起三次握手；
    1.  [ARP协议在同网段及跨网段下的工作原理](https://blog.csdn.net/JAZZSOLDIER/article/details/52635744?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)
    1.  三次挥手细节.....
1.  TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；
1.  ==HTTP请求==报文
    1.  请求行(方法,url,协议版本)
    1.  请求头(附加信息,如:编码,数据格式等等)
    1.  请求体(如post请求的参数)
1.  服务器接收到这个请求，并根据路径参数映射到特定的==请求处理器进行处理==，并将处理结果及相应的视图返回给浏览器；
    1.  中间可能经历负载均衡,Redis,数据库
1.  ==HTTP响应==报文
    1.  状态行(协议版本,状态码1xx表示继续处理,2xx表示成功,3xx表示重定向,4xx表示客户端错误,5xx表示服务端错误,状态码描述)
    1.  响应头,正文类型,编码等等
    1.  空行
    1.  响应数据,返回的内容
1.  ==浏览器解析并渲染视图==，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；
1.  浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。

## 2. TCP三次握手建立连接

1.  客户端向服务端发送==请求建立连接的报文==,其中夹杂了一个随机数seq(序号)=x
    1.  客户端从无状态改为等待回应
    1.  SYN = 1,表示是是一个请求或接受连接报文
1.  服务端收到请求后向客户端==发送确认报文段==,发送了一个seq=y,ask(确认号)=x+1
    1.  ==服务端==这时就会为连接==分配内存==,从监听建立请求改为等待确认的确认的状态
    1.  SYN = 1,表示是是一个请求或接受连接报文
    1.  这个报文和后面的报文中ACK(确认位)都为1,表示报文段有效
1.  客户端收到确认后,向服务端==发送确认的确认==,ack(确认号)=y+1
    1.  ==客户端==这时才会为连接==分配内存==,并从等待匹配请求变为已经建立连接
    1.  服务端也从等待确认的确认表尾已经建立连接

>   之所以要进行三次挥手,是防止服务端不知道客户端什么时候同意了建立连接的请求,有可能客户端已经挂机等等状况.
>
>   还有一个情况就是如果网络状态不好,客户端发的第一个请求连接报文在真正的连接结束后才到达,那么服务端就会多建立一个连接
>
>   SYN泛洪攻击(DDos):
>
>   ​		客户端不断的发送建立连接的请求报文,然后不做指示,就会让服务端为很多无效链接分配很多内存.

## 3. TCP四次挥手断开连接

1.  客户端发送释放连接的报文段
    1.  FIN(终止位)为1,说明这个报文后客户端不再发消息
1.  服务端返回一个响应,并继续传输自己没有传输完的数据
    1.  ACK
    1.  客户端收到这个响应就不能发送数据了
1.  服务端传输完数据后,发送一个连接释放报文段
    1.  ACK
    1.  FIN(终止位)为1,说明这个报文后服务端不再发消息
    1.  服务端发送完这个请求,就不能发送数据了
1.  客户端收到报文后,回复确认报文端,并等待一段时间
    1.  ACK
    1.  等待这段时间是为了防止最后的确认报文丢失了,当服务端长时间没有收到确认时,就会重发3.客户端在这段时间内是可能重复的对3进行确认的

>   让双方都知道一件事情,需要三次通信,但是考虑到服务端还有处理数据,就会多进行一次通信.

## 4. TCP和UDP的区别

1.  TCP面向连接,UDP无连接
1.  TCP可靠交付,UDP不可靠
1.  TCP只支持点到点,UDP支持一对一,一对多,多对多
1.  TCP面向字节流,UDP面向报文
1.  TCP有拥塞控制,适合传输文件,UDP没有,则适合媒体通信(丢少量的包影响不大)
1.  TCP首部开销20字节,UDP 8字节

## 5. TCP如何保障可靠传输

1.  数据包校验
1.  对数据包进行排序(按照确认号)
1.  应答机制(接收端发送确认,说明前面的包都收到了,窗口才会移动)
1.  超时重发(等待一个确认号一定时间后就会重发)

## 6. TCP的流量控制

​		==滑动窗口机制==

​		每次TCP都是在窗口内的包进行发送,一些包到达后(一个积累的过程),接收端就会发送一个确认号,说明这个确认号之前的包都收到了,那么窗口就会移动.

​		每次回复确认号时,都会发送接收方期望的窗口大小(也就是数据的发送速度),发送端根据这个窗口大小实时调整窗口的大小.当窗口为0时,不发送数据.

​		为了防止窗口大小从0重新调整的确认号丢失导致连接故障,发送端收到零窗口通知就会启动一个计时器,计时器到期就会发送请求报文询问此时的窗口大小.

## 7. TCP的拥塞处理

>   拥塞窗口是发送方根据网络的拥塞程度设定的窗口大小,实际的窗口大小是接收窗口和拥塞窗口中的较小值.

1.  慢开始
    1.  一开始拥塞窗口很小,此时以质数增长(x2)
1.  拥塞避免
    1.  当拥塞窗口大小达到ssthresh值时,改为常数增长(+1),在发生网络拥塞时,重新设置ssthresh为此时拥塞窗口大小的一半,并将拥塞窗口大小设为1
1.  快重传
    1.  当收到一个包的三次重复确认后,说明中间发送了丢包现象,立即进行补发
1.  快恢复
    1.  快重传发生的时候也认为此时发生了拥塞,但是将窗口大小置为ssthresh的一半,也就是快恢复

## 8. HTTPS和HTTP的区别

1.  HTTP协议运行在TCP之上,HTTPS运行在SSL之上,而SSL运行在TCP之上
1.  HTTP端口为80,HTTPS为443
1.  HTTPS由于加减密会速度满,但是保障安全
1.  HTTPS需要证书,证书需要在CA机构购买

## 9. SSL/TSL连接的建立过程

1.  C端向S端发送请求,连接到S端的443端口.==发送的信息是随机值1和C端支持的加密算法==.
1.  S端收到信息后进行==响应==,包括==随机值2和匹配好的协商加密算法==,这个加密算法是==C端发过来所支持的算法的子集==.
1.  S端发送给C端第二个响应,是==数字证书(自己制作,在ca机构中申请)==,数字证书必须要有一整套.可以自己制作也可以向组织申请(自己制作的证书会在客户端弹出不安全提醒).一整套证书其实就是一对==公钥和私钥==.传送的==证书是其中的公钥==.
1.  C端==解析证书==,这个工作是由客户端的TLS完成的.
    1.  首先会验证公钥是否有效(从 CA 验证该证书的合法性)
    1.  如果没问题,那么==生成一个随机值(预主密钥)==
1.  C端验证证书通过后,==通过随机值1,随机值2和预主密钥组装会话秘钥==.然后==通过证书的公钥加密会话秘钥==
1.  传送加密信息==传输的是加密后的会话秘钥==,让==服务端通过解密得到随机值1,随机值2和预主密钥==
1.  服务端==组装==出会话秘钥,应与客户端的会话秘钥一致
1.  客户端通知服务端后面的消息都会只用会话秘钥加密
1.  客户端通过会话秘钥==加密一条数据(前面的握手消息生成摘要)发送给服务端==,验证是否能正常接收消息
1.  服务端通知客户端后面的消息都会使用加密
1.  服务端通过会话秘钥==加密一条消息(握手过程的消息生成摘要)回传给客户端==,如果都能正常接收,那么表明SSL层连接建立完成

## 10. SSL证书的验证过程

>   ​		==首先从证书中获取证书的颁发机构，然后从浏览器系统中去寻找此颁发机构的根证书==。
>
>   ​		==如果是受信任的CA机构，我们就从根证书中获取到根公钥，用根公钥去解密证书的数字签名==，成功解密以后得到证书的指纹和指纹算法，指纹是证书内容通过指纹算法计算得到的一个hash值，这里我们称之为h1，h1代表证书的原始内容；然后用指纹算法对当前接收到的证书内容再进行一次hash计算得到另一个值h2，h2则代表当前证书的内容，如果此时h1和h2是相等的，就代表证书没有被修改过。如果证书被篡改过，h2和h1是不可能相同的，因为hash值具有唯一性，不同内容通过hash计算得到的值是不可能相同的
>
>   ​		有人说假如证书上的指纹是不法分子伪造的，伪造是没有用的，因为你伪造的指纹不可能用CA机构的根私钥去加密（根私钥是CA机构绝对保密的），伪造者只能拿自己的秘钥去加密这个伪造的指纹，但当我们拿机构的根公钥去解密伪造指纹的时候是不可能成功的（加密内容只能由一对公钥私钥解密）
>
>   ​		==在证书没有被修改过的基础上，再检查证书上的使用者的URL和我们请求的URL是否相等==，如果相等，那么就可以证明当前浏览器链接的网站也是正确的，而不是一些钓鱼网之类的

​		证书以证书链的形式组织，在颁发证书的时候==首先要有根CA机构颁发的根证书，再由根CA机构颁发一个中级CA机构的证书，最后由中级CA机构颁发具体的SSL证书==。

​		我们可以这样理解，根CA机构就是一个公司，根证书就是他的身份凭证，每个公司由不同的部门来颁发不同用途的证书，这些不同的部门就是中级CA机构，这些中级CA机构使用中级证书作为自己的身份凭证，其中有一个部门是专门颁发SSL证书，当把根证书，中级证书，以及最后申请的SSL证书连在一起就形成了证书链，也称为证书路径。

​		在验证证书的时候，浏览器会调用系统的证书管理器接口对证书路径中的所有证书一级一级的进行验证，只有路径中所有的证书都是受信的，整个验证的结果才是受信。

## 11. get和post区别

1.  get意味获取资源,post为提交资源(put修改,delete删除)
1.  get中的参数会放在url(==请求头==)后(英文字母原样发送,其他类型会将其编码为 application/x-www-form-urlencoded MIME 字符串,空格转换为+,其他字符BASE64加密),post会把参数放在==请求体==中(组织方式为application/x-www-form-urlencoded或者JSON,在请求头中有描述)
1.  post请求安全性更高
1.  post请求发送的数据量更多,get请求受限制于url的长度

## 12. Cookie和Session

1.  Cookie将信息存储在客户端,相当于客户端的缓存,Session将信息存储在服务器中
1.  Session依赖Cookie实现,细节是在Cookie中存储了一个SessionID,用这个SessionID从服务器的一个Map中取出Session(也相当一个Map)
1.  Cookie不安全,Session因为保存在服务器上,所以相对安全
1.  Session会增加服务器压力

>   Application是应用全局的属性,所有用户都可以使用

## 13. OSI网络体系

应(用层),表(示层),会(话层),传(输层),网(络层),数(据链路层),物(理层)

下层向上层提供服务,下层的包中封装了上层的包(网络请求是一个不断封装然后传输,最后不断解包得到数据的过程)