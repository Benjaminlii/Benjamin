# Redis面试中常见问题总结

------

[TOC]

------

## 1. Redis支持的数据类型

1.  string:字符串,能保存任何类型的数据,包括二进制数据,最大512M(单个的key-value)

    格式: set key value

1.  hash:哈希类型,是一个string类型的field和value的映射表(参考Map,name指的是数据类型的名称,下同)

    格式: hmset name key1 value1 key2 value2........

1.  list:列表,简单的字符串列表,按照插入顺序排序

    格式: lpush name value1 value2......

1.  set:集合,无序,成员唯一

    格式: sadd name value1 value2......

    通过哈希表实现

1.  zset:有序集和,每一个value都对应一个score(double类型)用以排序

    格式: zadd name score1 value1 score2 value2......

    zset的成员是唯一的,但分数(score)却可以重复

## 2. 什么是Redis的持久化

### (1). 概念

​		持久化就是将Redis中用内存存储的数据写入磁盘,下次启动Redis服务可以恢复到内存中

### (2). 方式

-   RDB:即Redis DataBase.就是将Redis中的数据写入磁盘中
    -   核心功能在于rdbSave(写入RDB文件)和rdbLoad(从文件加载到内存)两个函数
-   AOF:即Append-Only File.字面意思是只可追加的文件,也就是以重做日志的方式去存储Redis中数据的变化
    -   每次执行服务器(定时)任务时,flushAppendOnlyFile函数都会被调用执行两个操作
        -   WRITE:将缓存写入文件
        -   SAVE:将文件保存入磁盘
    -   会对过时的更改日志进行删除
    -   内容是redis通讯协议(==RESP==)格式的命令文本存储。即存储命令

### (3). 两种持久化比较

1.  aof文件比rdb更新频率高,优先使用aof
1.  aof更安全也更大
1.  rdb性能好一些(重启时并不是靠恢复,而是直接读取)
1.  如果两个方式都进行了配置,优先使用AOF

## 3. Redis通讯协议RESP

​		RESP是Redis客户端和服务端的一种通讯协议,请求格式都相同,使用数组搭配多行字符串.而返回有很多种

​		每一行消息是以\r\n结尾的,也就是分行

1.  单行回复: " + "开头
1.  错误消息: " - "开头
1.  整型数字: " : "开头
1.  批量回复: " $ "开头
1.  数组格式回复: " * "开头

### (1). 请求格式

```resp
*3				// 这里星号指数组,后面数字代表数组长度,也就是命令的分段数,后面会紧跟3个多行字符串
$3				// 美元符号指多行字符串,后面数字代表字符串长度
SET				// 这是多行字符串的内容
$3
KEY
$5
VALUE
```

### (2). 响应格式

​		1234四种格式的消息或者5复合前面4中基础格式的消息.

## 4. Redis的架构模式

### (1). 单机版

​		多个client连接==一个Redis服务端==

​		容量有限,处理能力有限

### (2). 主从复制

​		根据==一个主服务器复制出多个从服务器==,从服务器负责查询,主服务器进行数据的添加删除和修改.每当主服务器上的数据有变动时,会同步到从服务器上.

​		降低了master的读压力,但是没有缓解写压力.

### (3). 哨兵

​		在主从复制的基础上==添加了哨兵机制,主服务器下线时进行故障转移(将另一台从服务器切换为主服务器来预防单点故障)==.

-   监控:哨兵会不断检查主服务器和从服务器是否运作正常
-   提醒:当一台服务器出现问题时,会通过API向管理员或者应用程序发送通知
-   自动故障迁移:当主服务器不能正常工作时,哨兵会进行故障转移

​		优点是自动故障迁移,保证稳定性,缺点还是没有缓解主服务器的写压力

### (4). 集群(proxy)

​		使用代理进行服务的分发(通过hash).减缓各服务器的压力.

​		Twemproxy是Twitter开源的一个Redis和memcache轻量级代理服务器.

​		通过代理对象将写请求分发到多个主服务器上,将读请求分发到多个从服务器上.各个服务器之间进行同步.

​		优点在于增加了各种算法,合理的分配服务,还支持故障节点的自动删除.缺点是增加了新的proxy,需要维护.

### (5). 集群(直接连接)

​		Redis集群由对台Redis服务器组成,这种直连方式对服务器部分主从.每个节点要处理部分写请求和读请求.通过同步进行统一.

​		优点是可大量扩展,高可用(部分节点不可用时,整个集群还是工作的),自动故障处理.

​		缺点是资源隔离性较差,数据通过异步复制,不保证强一致性.

## 5. Redis分布式锁

-   setnx(key, value)
    -   “set if not exits”
    -   若该key-value不存在，则成功加入缓存并且返回1，否则返回0。
    -   相当于获取锁,如果key已经存在了,返回0
-   expire(key, seconds)
    -   设置key-value的有效期为seconds秒。
-   getset(key, value)
    -   先进行get获取原值,再设置新的值(用于解决死锁)

setnx和expire中间出现故障的解决办法:

   1.  放弃使用expire命令.将当前时间戳作为value存入此锁中，通过当前时间戳和Redis中的时间戳进行对比，如果超过一定差值，认为锁已经时效，防止锁无限期的锁下去.如果两个线程同时发现锁超时,可能会同时获取到锁.这个问题通过getset()解决,通过getset原子操作保证只能有

       ```java
       while(jedis.setnx(lock, now+超时时间)==0）{
           if(now>jedis.get(lock) && now>jedis.getset(lock, now+超时时间)){
               // 这里先判断锁是否过期
               // 然后如果锁过期了,尝试竞争锁,只有一个线程能成功正确的返回之前的过期时间
               // 这时多个线程中的其他线程都会返回新的超时时间
               // 这个超时时间被更改并不重要,主要就是用于防止永久锁,问题不大
               break;
           }else{
               Thread.sleep(300);
           }
       }
       // 执行业务代码;
       jedis.del(lock);
       ```

   2.  合并命令

       ```redis
       // redis6.2后可将上述两步合并起来
       set key value seconds milliseconds nx|xx
       
       // seconds:秒
       // milliseconds：毫秒
       // nx：只有键不存在时，才对键进行设置操作
       // xx：只有键存在时，才对键进行设置操作
       // set操作成功完成时，返回ok，否则返回nil
       ```

       



