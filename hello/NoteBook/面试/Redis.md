# Redis面试中常见问题总结

------

[TOC]

------

## 1. Redis支持的数据类型

1.  string:字符串,能保存任何类型的数据,包括二进制数据,最大512M(单个的key-value)

    格式: set key value

1.  hash:哈希类型,是一个string类型的field和value的映射表(参考Map,name指的是数据类型的名称,下同)

    格式: hmset name key1 value1 key2 value2........

1.  list:列表,简单的字符串列表,按照插入顺序排序

    格式: lpush name value1 value2......

1.  set:集合,无序,成员唯一

    格式: sadd name value1 value2......

    通过哈希表实现

1.  zset:有序集和,每一个value都对应一个score(double类型)用以排序

    格式: zadd name score1 value1 score2 value2......

    zset的成员是唯一的,但分数(score)却可以重复

## 2. 什么是Redis的持久化

### (1). 概念

​		持久化就是将Redis中用内存存储的数据写入磁盘,下次启动Redis服务可以恢复到内存中

### (2). 方式

-   RDB:即Redis DataBase.就是将Redis中的数据写入磁盘中
    -   核心功能在于rdbSave(写入RDB文件)和rdbLoad(从文件加载到内存)两个函数
-   AOF:即Append-Only File.字面意思是只可追加的文件,也就是以重做日志的方式去存储Redis中数据的变化
    -   每次执行服务器(定时)任务时,flushAppendOnlyFile函数都会被调用执行两个操作
        -   WRITE:将缓存写入文件
        -   SAVE:将文件保存入磁盘
    -   会对过时的更改日志进行删除
    -   内容是redis通讯协议(==RESP==)格式的命令文本存储。即存储命令

### (3). 两种持久化比较

RDB特点:

-   方便备份(直接将文件解压,复制)
-   性能最大化,只占用子进程进行持久化
-   数据集很大的情况下启动快速
-   安全性不高,宕机只能恢复上一次持久化的数据
-   数据集较大的情况下子进程的持久化可能会使服务有较大时间的阻塞

AOF特点:

-   高数据安全性,宕机不会丢失数据
-   提供了每秒同步,每修改同步和不同步,每秒同步会丢失一秒内的数据,每修改同步效率低下
-   如果日志过大,启动初始化时间过长,会用新的文件存储这个时间内的操作,一旦准备好第二个文件，Redis会切换这两个文件并开始追加到新的那一个
-   文件大小大于RDB
-   日志改写:会删除之前失效的日志

### (4). RDB细节

#### 1). 工作原理

### (5). AOF细节

#### 1). AOF文件的存储

​		Redis调用flushAppendOnlyFile函数执行WRITE(将缓存写入内存中的AOF文件中)和SAVE(将AOF文件从内存持久化到磁盘)两个工作.

​		支持三种工作方式:

-   每秒同步:==原则上==每秒进行一次同步,SAVE由子线程执行,不会引起主线程恩阻塞
    -   当进行同步时,子线程正在进行同步,如果子线程同步未超过2秒,那么跳过本次同步,如果超过,本次不进行SAVE(原因是本次的WRITE延迟,要避免影响到下一次同步)
    -   子线程没在进行同步,如果距离上一次同步不超过一秒,不进行SAVE
    -   性能与安全性兼顾
-   每命令同步:每执行一次任务同步一次,==SAVE是由主线程执行的,会阻塞主线程==
    -   安全性最高,但是效率被同步拉低
-   不同步:==Redis被关闭,AOF功能被关闭==,或者==系统缓存被刷新==时会阻塞主线程进行SAVE
    -   宕机会丢失数据,但是不用进行同步所以效率最高

#### 2). 文件读取和数据还原

​		AOF文件采用RESP通讯协议保存命令.

​		只要根据AOF文件中的协议,重新执行一遍AOF文件中的所有命令就可以还原Redis的数据了.

步骤:

1.  创建一个不连接网络的伪客户端
1.  读取AOF文件,还原出命令以及参数
1.  使用伪客户端执行这些命令

使用伪客户端的原因是恢复数据不需要网络,效果完全一样.

#### 3). AOF重写

​		Redis会在AOF文件中进行命令的重写,==相当于合并命令到另一个文件==,这个过程在子线程中进行,主线程可以继续处理命令请求.

​		==重写期间的命令会写入重写缓冲区==,在重写完成之后==追加在新AOF文件末尾==.

​		这个过程完成之后使用新的AOF文件代替原来的旧文件.

## 3. Redis通讯协议RESP

​		RESP是Redis客户端和服务端的一种通讯协议,请求格式都相同,使用数组搭配多行字符串.而返回有很多种

​		每一行消息是以\r\n结尾的,也就是分行

1.  单行回复: " + "开头
1.  错误消息: " - "开头
1.  整型数字: " : "开头
1.  批量回复: " $ "开头
1.  数组格式回复: " * "开头

### (1). 请求格式

```resp
*3				// 这里星号指数组,后面数字代表数组长度,也就是命令的分段数,后面会紧跟3个多行字符串
$3				// 美元符号指多行字符串,后面数字代表字符串长度
SET				// 这是多行字符串的内容
$3
KEY
$5
VALUE
```

### (2). 响应格式

​		1234四种格式的消息或者5复合前面4中基础格式的消息.

## 4. Redis的架构模式

### (1). 单机版

​		多个client连接==一个Redis服务端==

​		容量有限,处理能力有限

### (2). 主从复制

​		根据==一个主服务器复制出多个从服务器==,从服务器负责查询,主服务器进行数据的添加删除和修改.每当主服务器上的数据有变动时,会同步到从服务器上.

​		降低了master的读压力,但是没有缓解写压力.

### (3). 哨兵

​		在主从复制的基础上==添加了哨兵机制,主服务器下线时进行故障转移(将另一台从服务器切换为主服务器来预防单点故障)==.

-   监控:哨兵会不断检查主服务器和从服务器是否运作正常
-   提醒:当一台服务器出现问题时,会通过API向管理员或者应用程序发送通知
-   自动故障迁移:当主服务器不能正常工作时,哨兵会进行故障转移

​		优点是自动故障迁移,保证稳定性,缺点还是没有缓解主服务器的写压力

### (4). 集群(proxy)

​		使用代理进行服务的分发(通过hash).减缓各服务器的压力.

​		Twemproxy是Twitter开源的一个Redis和memcache轻量级代理服务器.

​		通过代理对象将写请求分发到多个主服务器上,将读请求分发到多个从服务器上.各个服务器之间进行同步.

​		优点在于增加了各种算法,合理的分配服务,还支持故障节点的自动删除.缺点是增加了新的proxy,需要维护.

### (5). 集群(直接连接)

​		Redis集群由对台Redis服务器组成,这种直连方式对服务器部分主从.每个节点要处理部分写请求和读请求.通过同步进行统一.

​		优点是可大量扩展,高可用(部分节点不可用时,整个集群还是工作的),自动故障处理.

​		缺点是资源隔离性较差,数据通过异步复制,不保证强一致性.

## 5. Redis分布式锁

-   setnx(key, value)
    -   “set if not exits”
    -   若该key-value不存在，则成功加入缓存并且返回1，否则返回0。
    -   相当于获取锁,如果key已经存在了,返回0
-   expire(key, seconds)
    -   设置key-value的有效期为seconds秒。
-   getset(key, value)
    -   先进行get获取原值,再设置新的值(用于解决死锁)

setnx和expire中间出现故障的解决办法:

   1.  放弃使用expire命令.将当前时间戳作为value存入此锁中，通过当前时间戳和Redis中的时间戳进行对比，如果超过一定差值，认为锁已经时效，防止锁无限期的锁下去.如果两个线程同时发现锁超时,可能会同时获取到锁.这个问题通过getset()解决,通过getset原子操作保证只能有

       ```java
       while(jedis.setnx(lock, now+超时时间)==0）{
           if(now>jedis.get(lock) && now>jedis.getset(lock, now+超时时间)){
               // 这里先判断锁是否过期
               // 然后如果锁过期了,尝试竞争锁,只有一个线程能成功正确的返回之前的过期时间
               // 这时多个线程中的其他线程都会返回新的超时时间
               // 这个超时时间被更改并不重要,主要就是用于防止永久锁,问题不大
               break;
           }else{
               Thread.sleep(300);
           }
       }
       // 执行业务代码;
       jedis.del(lock);
       ```

   2.  合并命令

       ```redis
       // redis6.2后可将上述两步合并起来
       set key value seconds milliseconds nx|xx
       
       // seconds:秒
       // milliseconds：毫秒
       // nx：只有键不存在时，才对键进行设置操作
       // xx：只有键存在时，才对键进行设置操作
       // set操作成功完成时，返回ok，否则返回nil
       ```

       



