------

[TOC]

-----------

## 1. 自我介绍

>   ​		面试官您好,我叫李涛,是一名来自西安邮电大学的大三学生.
>
>   ​		大一的时候学习了一些比较基础的知识(C语言,数据结构).在大二期间也就是去年的这个时候,加入了我们学院的一个实验室.后面就一直在学习Java后台方向的技术.在实验室学习期间,在学长的指导下和实验室的小伙伴做过一些项目,主要是想把自己学到的知识加以应用,更好的理解.
>
>   ​		我在大学期间成绩一直算年级的前列,大二全年的成绩在年级的前十,大一和大二都获得了校级的奖学金.大二至今担任了自己班级的班长,锻炼了一部分处理问题和沟通交流的能力.
>
>   ​		如今是想趁着春招来获得一次实习的机会,来了解实际公司中的开发场景,并且再拓展一些自己的知识.
>

## 2. 项目总结

### (1). 简介

​		superbuy项目

​		西安邮电大学校园超市网上订单平台，通过网上下单购买校园超市商品。可以实时查询订单详情，能够根据当天销售情况进行统计，进行实时的排行榜。

​		Spring+SpringMVC+MyBatis+MySQL+Redis+Dubbo+Zookeeper

​		使用MD5加密技术来保证用户敏感信息的安全性。

​		利用Redis缓存减少频繁性操作对数据库的压力。

​		对相应的查询功能进行了优化，保证数据库的性能。同时使用乐观锁做了并发的支持,避免出现修改值的覆盖现象.

​		采用Dubbo作为分布式框架，进行分布式集群搭建，使各层之间解耦合，便于项目的后续管理和产品迭代升级。

### (2). 分布式拆分

​		顶层项目parent

​		横向对业务逻辑和数据库持久化抽离为微服务(controller层为一个单独的服务,service和dao为单独的一个服务).

​		纵向对定时任务，支付模块，各自抽出为一个微服务.

​		单独抽离出公共模块(常量Constants,util等等)和接口模块(包括服务层的接口和实体类)

### (3). 难点

​    	首页实时排行对数据库压力太大，使用redis缓存实现。排行榜不进行持久化。

​		另外设计了排行榜表项实体类，用于数据封装，传出。定时任务的日统计中使用Redis创建一个晚上十二点过期的zset,存储商品信息和销售额.不在数据库中进行持久化

​		统计操作使用定时任务进行,每日凌晨0点,每周一凌晨0点,每月1日凌晨0点,每年第一天凌晨0点都进行一次,统计销量,使用标记位区分.定时任务使用spring task解决.每三小时更新从数据库查询进行统计,更新一次Redis中zset中的数据.

​    	商品超卖现象(商品数量为1是,两个事务同时进行修改,其中一个会被阻塞,但是阻塞过后会覆盖之前的修改)，使用乐观锁实现,建立版本字段,就是最后一次修改的时间戳,先查询版本,然后得到商品数量,更改时对版本进行比对,如果对不上,那么回滚事务,并且返回特定的提示信息,提示用户购买失败,刷新回商品页面.

#### 1). 鉴权

​		考虑到项目如果多服务器部署的话session是不可用的,并且session要占用大量的服务器内存来存储session中的信息.改用Redis+Token的鉴权方式,在未来做拓展时就可以很好的支持.

1.  使用Redis+Token的方式鉴权.[Java Token的原理和生成使用机制](https://blog.csdn.net/myjbase/article/details/91869537)

1.  用户第一次登录时,后台通过算法(UUID,要是多服务器拓展,也可以使用)生成这个用户的Token(令牌),然后将这个Token通过session中的setAttribute发送回客户端,客户端进行加密存储.

1.  服务端将这个Token和user对象的JSON字符串作为键值对存储到Redis中,并给这个键设置存活时间30分钟.

1.  每次接收请求都在拦截器(spring中使用@WebFilter注解定义过滤器)中进行判断token是否存在,不存在则说明没登录,进行跳转到登录页面.登录和主页请求不进行拦截,在拦截器中拦截所有请求,然后根据path的前缀进行区分,实现不同的行为.

1.  ```java
    String path = ((HttpServletRequest) request).getRequestURI();
    if (path.startsWith("/specialPath/")) {
        chain.doFilter(request, response); // 排除的url
    } else {
        // 拦截的url
    }
    ```

1.  然后在Redis中查找这个Token对应的user的JSON字符串,不存在表示Token过期,存在则重新设置存活时间为30分钟.

1.  最后根据token从Redis中取出user的JSON字符串,转化成user对象,得到用户信息存储在Request中.controller中使用@RequestAttribute注解获得Request的attribute中的参数.

1.  用户的退出登录操作就是服务端删除Redis中的键值对.

>   关于token的安全问题(token被暴力破解):
>
>   ​		初次登录时,在数据库中进行查询,得到用户信息.服务端生成一个uuid,在Redis进行存储(在一个map中存储key为uuid,value为user对象的JSON字符串).客户端对称加密存储.
>
>   ​		后面每次客户端访问时,发来uuid,本次访问时间戳,和这两个值的校验和(加密,任意方式都可以,MD5).
>
>   ​		服务端收到请求后,在拦截器中得到uuid,本次访问时间戳,去Redis中查询user对象,并且根据相同的算法得到相同的校验和就证明身份正确.

#### 2). 限流

​		没有实现令牌桶,原因是Redis还不是很了解(lua哪里),退而求其次使用了方案一.

​		方案一:

1.  使用Redis中的计数器和带时间的键来完成限流,这也相当于令牌桶,只不过令牌一次性放置,很生硬
1.  如果要完成1秒内1w的限流
1.  那么在Redis中建立一个count = 0,和一个键存活时间为1秒的键
1.  在这个键有效并且count小于1w时,可以访问并且count++,否则进行拦截

​		方案二:

1.  Redis+lua实现的令牌桶限流
1.  首先说说概念,令牌桶是指一个Token池,按照一定的速率往里面放令牌(桶满了则停止放置),每次要进行访问时,都先从桶中取令牌,取得了令牌才可以访问,否则被限流.

### (4). 数据库

​    	商品实体:id,名称,商品图片路径,类型,上架时间,数量,描述,标记字段(下架,售空),备注

​		订单记录:id,商品id,用户id,数量(单个商品的多个数量),产生的销售额,订单状态(下单,配送,完成),下单时间

​		账户:id,用户id,账户余额,用户消费金额(统计使用,没做)

​		充值记录:id,账户id,充值金额,充值时间,充值渠道(支付宝,微信),充值的订单号,充值订单状态(充值中,成功,失败)

​		用户:id,用户名,手机号,密码(md5加密后的,前端进行加密),用户姓名,身份证号码(调京东接口校验身份),注册时间,上次登录时间,头像文件路径

​		排行榜实体(不存数据库):商品名:商品出售金额

​		统计信息:商品id,商品销量,商品销售额,标记位(年统计,月统计,周统计,日统计),年,月,周(按年划分的周)(后面这三个默认值为-1,为不存在,避免使用null)

​		(配送员，配送记录)


​     

## 2. 实习经历

小米用户中心部门,2019.12~2020.2

一开始熟悉业务,学习技术栈

改了个bug,就jsp页面

>   工作内容:
>
>   我的帖子页面:
>
>    背景:
>
>   1.  社区发帖，采用先发后审机制，审核不通过后直接下线处理，有嫌疑的帖子送到人工审核；
>   1.  若人工审核未完成，就会一直挂在审核中，用户侧感知太弱；
>   1.  审核过程中，机审误判的帖子、评论，直接下线后，造成用户尝试多次发帖、投诉等；
>
>   方案
>
>   1.  提供一个内容发表之后的聚合页面，可以囊括所有帖子；
>   1.  用户能看到自己所有的帖子列表及对应的帖子状态；
>   1.  用户能够直接查看每个帖子的详情页，只是里面有一个tips提醒；而不是错误页进行拦截；
>
>   实现功能:
>
>   1.  原先发帖先进行机审,不通过直接下线,模糊则进行人工审核,状态为审核中,
>   1.  现在可以查看正在审核的帖子(提供聚合页面,囊括所有帖子,原先的我的帖子页面没有审核中的帖子,下线帖子和人工审核帖子通过系统消息得知),进入审核中的帖子会有顶部的标记,下线的帖子可以进行申诉
>   1.  实现所有帖子的查看:数据库查询,返回所有符合标记的帖子
>   1.  实现申诉:新建表存储申诉信息,申诉则填写信息存储
>   1.  处理申诉:更新申诉信息,和帖子信息,发送系统消息
>   1.  复杂的地方:
>       1.  在帖子状态的标记字段(正常上线或者下线或者审核中)增加若干字段(待审核,删除,下线-原因)
>       1.  下线的帖子15天改为删除状态,在页面中要显示剩余时间就要对这种类型的帖子进行特殊对待,要将发布日期和当前时间进行计算,得到剩余时间.使用map接收的时候,过期的帖子加一个字段
>       1.  申诉期有限,所以在工作人员查询申诉信息的时候根据申诉时间进行排序,将越早的排列在越前面(不加索引,需求很小),避免饥饿



