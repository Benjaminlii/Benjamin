------

[TOC]

-----------

## 1. 自我介绍

>   ​		面试官您好,我叫李涛,是一名西安邮电大学软件工程专业即将升大四的学生。
>
>   ​		大学期间获得过两次奖学金，也担任了班长。
>
>   ​		我从大二加入了实验室，开始学习Java后端方向的知识和技术。在实验室期间和同组同学一起做了一些项目，简历中有所介绍。
>
>   ​		后面去了字节和菜鸟实习。在字节实习是流程平台部门，是字节内部的需求、项目流程管理平台，实习时间比较短而且是远程，主要是对Goland进行了一些学习，了解了基础知识之后，做了一些小的需求和一个平台的美东部署。
>
>   ​		后面5月底阿里通知我过了（拖得时间比较久），并且因为一些个人原因，主要是考虑到和女朋友异地的原因，就去了杭州。
>
>   ​		然后去菜鸟那边是关务平台，是主要负责菜鸟物流通关域也就是海关申报的平台。阿里的节奏比较紧张所以两个月的实习做的事情还是很多的。进部门做了一个小的需求之后，负责了一个考拉融合菜鸟物流的项目其中的支付流对接项目，将原本只支持支付宝的支付流申报进行功能拓展，进而支持多种支付方式，并且要考虑后续的拓展等等，简历中有介绍。在实习期间也学习了很多集团的技术，其中比较详细了解的是部门自研的中间件流程引擎，查阅过源码，对具体实现有比较深入的了解。
>
>   ​		但是实习一段时间发现转正欲望不是很强烈，因为在杭州比较孤独哈，我们这一届大部份同学都是去了北京，在杭州只有我一个，加上我女朋友那边也是想回北方发展，考虑了很久就还是打算秋招回北京。

## 2. 项目总结（superbuy）

### (1). 简介

​		superbuy项目

​		西安邮电大学校园超市网上订单平台，通过网上下单购买校园超市商品。可以实时查询订单详情，能够根据当天销售情况进行统计，进行实时的排行榜。

​		Spring+SpringMVC+MyBatis+MySQL+Redis+Dubbo+Zookeeper

​		使用MD5加密技术来保证用户敏感信息的安全性。

​		利用Redis缓存减少频繁性操作对数据库的压力。

​		对相应的查询功能进行了优化，保证数据库的性能。同时使用乐观锁做了并发的支持,避免出现修改值的覆盖现象.

​		采用Dubbo作为分布式框架，进行分布式集群搭建，使各层之间解耦合，便于项目的后续管理和产品迭代升级。

### (2). 分布式拆分

​		顶层项目parent

​		横向对业务逻辑和数据库持久化抽离为微服务(controller层为一个单独的服务,service和dao为单独的一个服务).

​		纵向对定时任务，支付模块，各自抽出为一个微服务.

​		单独抽离出公共模块(常量Constants,util等等)和接口模块(包括服务层的接口和实体类)

### (3). 难点

​    	首页实时排行对数据库压力太大，使用redis缓存实现。排行榜不进行持久化。

​		另外设计了排行榜表项实体类，用于数据封装，传出。定时任务的日统计中使用Redis创建一个晚上十二点过期的zset,存储商品信息和销售额.不在数据库中进行持久化

​		统计操作使用定时任务进行,每日凌晨0点,每周一凌晨0点,每月1日凌晨0点,每年第一天凌晨0点都进行一次,统计销量,使用标记位区分.定时任务使用spring task解决.每三小时更新从数据库查询进行统计,更新一次Redis中zset中的数据.

​    	商品超卖现象(商品数量为1是,两个事务同时进行修改,其中一个会被阻塞,但是阻塞过后会覆盖之前的修改)，使用乐观锁实现,建立版本字段,就是最后一次修改的时间戳,先查询版本,然后得到商品数量,更改时对版本进行比对,如果对不上,那么回滚事务,并且返回特定的提示信息,提示用户购买失败,刷新回商品页面.

#### 1). 鉴权

​		考虑到项目如果多服务器部署的话session是不可用的,并且session要占用大量的服务器内存来存储session中的信息.改用Redis+Token的鉴权方式,在未来做拓展时就可以很好的支持.

1.  使用Redis+Token的方式鉴权.[Java Token的原理和生成使用机制](https://blog.csdn.net/myjbase/article/details/91869537)

1.  用户第一次登录时,后台通过算法(UUID,要是多服务器拓展,也可以使用)生成这个用户的Token(令牌),然后将这个Token通过session中的setAttribute发送回客户端,客户端进行加密存储.

1.  服务端将这个Token和user对象的JSON字符串作为键值对存储到Redis中,并给这个键设置存活时间30分钟.

1.  每次接收请求都在拦截器(spring中使用@WebFilter注解定义过滤器)中进行判断token是否存在,不存在则说明没登录,进行跳转到登录页面.登录和主页请求不进行拦截,在拦截器中拦截所有请求,然后根据path的前缀进行区分,实现不同的行为.

1.  ```java
    String path = ((HttpServletRequest) request).getRequestURI();
    if (path.startsWith("/specialPath/")) {
        chain.doFilter(request, response); // 排除的url
    } else {
        // 拦截的url
    }
    ```

1.  然后在Redis中查找这个Token对应的user的JSON字符串,不存在表示Token过期,存在则重新设置存活时间为30分钟.

1.  最后根据token从Redis中取出user的JSON字符串,转化成user对象,得到用户信息存储在Request中.controller中使用@RequestAttribute注解获得Request的attribute中的参数.

1.  用户的退出登录操作就是服务端删除Redis中的键值对.

>   关于token的安全问题(token被暴力破解):
>
>   ​		初次登录时,在数据库中进行查询,得到用户信息.服务端生成一个uuid,在Redis进行存储(在一个map中存储key为uuid,value为user对象的JSON字符串).客户端对称加密存储.
>
>   ​		后面每次客户端访问时,发来uuid,本次访问时间戳,和这两个值的校验和(加密,任意方式都可以,MD5).
>
>   ​		服务端收到请求后,在拦截器中得到uuid,本次访问时间戳,去Redis中查询user对象,并且根据相同的算法得到相同的校验和就证明身份正确.

#### 2). 限流

​		没有实现令牌桶,原因是Redis还不是很了解(lua哪里),退而求其次使用了方案一.

​		方案一:

1.  使用Redis中的计数器和带时间的键来完成限流,这也相当于令牌桶,只不过令牌一次性放置,很生硬
1.  如果要完成1秒内1w的限流
1.  那么在Redis中建立一个count = 0,和一个键存活时间为1秒的键
1.  在这个键有效并且count小于1w时,可以访问并且count++,否则进行拦截

​		方案二:

1.  Redis+lua实现的令牌桶限流
1.  首先说说概念,令牌桶是指一个Token池,按照一定的速率往里面放令牌(桶满了则停止放置),每次要进行访问时,都先从桶中取令牌,取得了令牌才可以访问,否则被限流.

### (4). 数据库

​    	商品实体:id,名称,商品图片路径,类型,上架时间,数量,描述,标记字段(下架,售空),备注

​		订单记录:id,商品id,用户id,数量(单个商品的多个数量),产生的销售额,订单状态(下单,配送,完成),下单时间

​		账户:id,用户id,账户余额,用户消费金额(统计使用,没做)

​		充值记录:id,账户id,充值金额,充值时间,充值渠道(支付宝,微信),充值的订单号,充值订单状态(充值中,成功,失败)

​		用户:id,用户名,手机号,密码(md5加密后的,前端进行加密),用户姓名,身份证号码(调京东接口校验身份),注册时间,上次登录时间,头像文件路径

​		排行榜实体(不存数据库):商品名:商品出售金额

​		统计信息:商品id,商品销量,商品销售额,标记位(年统计,月统计,周统计,日统计),年,月,周(按年划分的周)(后面这三个默认值为-1,为不存在,避免使用null)

​		(配送员，配送记录)

## 3. 项目总结（支付流）

### (1). 简介

考拉融入阿里电商体系中，接入菜鸟物流通关域大项目中的一个子模块。

物流通关需要行海关提交支付单信息，但原系统只支持支付宝支付单信息的推送。需要对系统进行拓展从而支持考拉自身的多种支付方式。

灰度开关，白名单

### (2). 难点

关于可拓展性设计，每个申报处理节点都继承自一个抽象类，这个抽象类中定义了申报的流程，基础数据校验，报文拼接，报文后置校验，报文发送，报文发送后置处理，每个节点中注入校验器，报文组装器，后置处理器，抽象类中通过get方法获得这些bean，调用其方法进行处理，子类中只需要实现各个校验器，报文组装器，后置处理器，重写get方法，完全不需要关注流程，进行了解耦。对各个支付单处理节点的spring类注册名进行了约定。在实际流程中会先访问到一个支付单处理门面节点，在这个节点中对支付方式进行路由，分发到具体的实现类中。

用到了很多自研的技术，所以在开发过程中要不断的学习，挺有挑战的。

应用了部门中间件流程引擎，门面路由到具体的处理节点，达到可拓展的设计。项目运用了中间件流程引擎，将每一个单独的动作和状态之间的流转解耦，节点内代码控制节点进行的动作，用流程图文件去控制节点间状态的流转。通过异步调度任务完成流程节点的执行和失败补偿。

异步调度任务，各个流程节点之间解耦合，并且支持失败补偿（这一块，申报结果间断查询依靠这个实现）

通过网关对外部交换，内部封装相同的报文，发送不同的请求时，通过脚本转化为不同的具体需要的数据格式。



进行申报需要一些用户的隐私信息，如密钥之类的，不仅需要应用已有的密钥管理解决方案，还需要和业务方进行沟通。

整个项目牵扯到很多链路，比如进口（上游）、考拉交易侧（业务方）、支付方。对一个实习生来说，沟通上也是挺有挑战的。

## 2. 实习经历

### (1). 小米

用户中心部门,2019.12~2020.2

一开始熟悉业务,学习技术栈

改了个bug,就jsp页面

>   工作内容:
>
>   我的帖子页面:
>
>    背景:
>
>   1.  社区发帖，采用先发后审机制，审核不通过后直接下线处理，有嫌疑的帖子送到人工审核；
>   1.  若人工审核未完成，就会一直挂在审核中，用户侧感知太弱；
>   1.  审核过程中，机审误判的帖子、评论，直接下线后，造成用户尝试多次发帖、投诉等；
>
>   方案
>
>   1.  提供一个内容发表之后的聚合页面，可以囊括所有帖子；
>   1.  用户能看到自己所有的帖子列表及对应的帖子状态；
>   1.  用户能够直接查看每个帖子的详情页，只是里面有一个tips提醒；而不是错误页进行拦截；
>
>   实现功能:
>
>   1.  原先发帖先进行机审,不通过直接下线,模糊则进行人工审核,状态为审核中,
>   1.  现在可以查看正在审核的帖子(提供聚合页面,囊括所有帖子,原先的我的帖子页面没有审核中的帖子,下线帖子和人工审核帖子通过系统消息得知),进入审核中的帖子会有顶部的标记,下线的帖子可以进行申诉
>   1.  实现所有帖子的查看:数据库查询,返回所有符合标记的帖子
>   1.  实现申诉:新建表存储申诉信息,申诉则填写信息存储
>   1.  处理申诉:更新申诉信息,和帖子信息,发送系统消息
>   1.  复杂的地方:
>       1.  在帖子状态的标记字段(正常上线或者下线或者审核中)增加若干字段(待审核,删除,下线-原因)
>       1.  下线的帖子15天改为删除状态,在页面中要显示剩余时间就要对这种类型的帖子进行特殊对待,要将发布日期和当前时间进行计算,得到剩余时间.使用map接收的时候,过期的帖子加一个字段
>       1.  申诉期有限,所以在工作人员查询申诉信息的时候根据申诉时间进行排序,将越早的排列在越前面(不加索引,需求很小),避免饥饿

### (2). 字节跳动

流程平台 2020.4-2020.6

#### 1). 需求

后端配置迁移：将硬编码的后端配置集中配置在配置管理中心，通过网络请求去获取配置

数据库增加修改人：数据库中的修改新增操作设置操作者

两个需求都是为了熟悉业务代码，了解项目结构。

#### 2). 美东部署

资源申请

数据同步方案：

1. 双写（异步）
2. 消息队列



### (3). 菜鸟网络

关务平台 2020.6-2020.8

#### 1). VINCI

流程引擎

无持久化，节点无状态。所以运行速度上要快很多。

流程图文件借助于开源的BPMN标准。

流程引擎的核心类包括：handler管理器（handler manger），节点调度器（process engine），流程上下文（event），初始化构造器（init），流程管理器，handler基类。

其他：调度执行接口（具体项目中实现，通过配置注入到节点调度器中）

一个流程节点的执行包括：当前节点的查找，节点的调度执行，根据节点执行结果判断是否补偿重试，后继节点计算，后继节点的流转

每一次调度都会带有一个流程上下文传入，其中会包含当前的解决方案id（solution id），和应该调度的节点类型（event type）。通过eventType在handler管理器中找到具体的执行handler，通过调度执行接口进行调度（调度方式在项目中实现）。所有handler都继承自顶层的handler基类，在这个类中最后会进行后继节点的流转。流转包括后继节点计算和后继节点的调度。节点计算是通过solutionId和EventType寻找下一个节点，得到下一个节点的eventType后重复进行调度。

关于异步：项目中应用到的异步是初始节点启动一个异步任务，在异步任务中进行handler的执行，这个异步任务执行的末尾会开启新的异步任务，流转下一个节点。

> 设计上:
>
> 自定义@handler注解，通过扫描bean是否实现了这个注解来判断这个对象是否是一个handler。
>
> 将节点的具体调度执行以接口的方式空缺，这样可以更具灵活性，项目中可以根据自己需要选择不同的调度方式。
>
> 在开源的流程图标准BPMN的基础上进行开发，避免不必要的开发。
>
> 不进行持久化，使用Map来存储流程图和流程节点，追求速度。
>
> 提供一个handler基类，大致定义了核心执行逻辑，提供一个方法给子类定义自己的业务逻辑，子类中又可以进一层的进行抽象定义，最终把具体业务中的每一步都可以分开解耦合。
>
> 在流程图中节点流转处，也就是流程图对应的BPMNXML文件中的一条路径，中定义一些固定的判别条件，例如延迟时间，这样就可以达到控制调度的目的。也可以增加一些对数据的判断，例如某个状态是什么，这样可以从event中取出状态进行判断，从而做到流程的条件流转。

