# 四. Golang高级编程

-----

[toc]

-----

## 1. 文件

常用文件操作函数:

### (1). 读文件

```go
// 只读打开一个文件
os.Open(name string) (*File, error)

// 获取到一个文件的带缓冲reader
// 默认缓冲区未4096byte
bufio.Newreader(file File) *Reader

// 读取数据
// 从文件中一直读取数据，直到ch符号停止
// error是返回的错误，但如果是io.EOF，则表示文件到了末尾
(r *Reader) ReaderString(ch byte) (string, error)

// 一次性读取文件
// error如果为nil，表示读取成功
ioutil.ReadFile(fileName string) ([]byte, error)

// 关闭一个文件
(f *File) Close()
```

### (2). 写文件

```go
// 通过参数传递的选项打开指定名称的文件
// 第二个参数：os.O_XXXXXX等常量，可以使用｜连接
// 第三个参数：linux下的八进制文件权限（0666，前面的0表示八进制）
os.OpenFile(name string, flag int, perm FileMode) (file *File, err error)

// 得到一个带缓存的Writer
bufio.NewWriter(file File) *Writer

// 写入一个字符串到缓冲中
// 返回一个字节数，如果和传入的字符串的长度不想等，还会传出一个错误
(b *Writer) WriterString(str string) (int, error)

// 将缓冲区中的字节刷新到磁盘
(b *Writer) Flush() error

// 关闭一个文件
(f *File) Close()
```

## 2. JSON

```go
// 将任意类型转化为JSON字符串
// 序列化时使用tag进行字段名的设置
encoding/json.Marshal(v interface{}) ([]byte, error)

// 反序列化
// data即为转化为[]byte的字符串
// v是一个指针，用来接收反序列化后的实例
// 转化失败会报错
encoding/json.Unmarshal(data []byte, v interface{}) error
```

## 3. 协程和管道

### (1). 协程

​		协程相当于Java中的线程（但是轻量级的），而管道则是多个协程之间通信的方式。

```go
func doInGoroutine() {
	for i := 0; i < 10; i++ {
		fmt.Println("hello", i)
		time.Sleep(time.Second)
	}
}

func doMaster() {
	for i := 0; i < 10; i++ {
		fmt.Println("world", i)
		time.Sleep(time.Second)
	}
}

func main() {
    // Golang中在go关键字之后调用函数或者方法即可在新的一个协程中执行这个方法
	go doInGoroutine()
	doMaster()
}
```

### (2). 锁

​		适用于低水平程序线程，高水平的同步使用channel通信更好一些。

```go
// 声明一个全局变量锁
var sync.Mutex

// 加锁
(m *Mutex) Lock()
// 解锁，如果解锁是未加锁，会有运行时错误
(m *Mutex) UnLock()
```

### (3). 管道

​		相当于一个线程安全的FIFO的队列，可用于协程之间传递数据。

​		channel也有类型。且长度不可扩充。

```go
// 管道是引用类型，且必须有类型
// 管道需要先进行分配内存，即make后才能使用
// 管道的长度是不可变的
// 其使用价值在于一边放，一边取
var channel chan int = make(chan int, 10)

// 管道的入元素
// 如果管道满了，会报错
channel<- 100

// 管道的取元素
// 如果管道是空的，会报错
// 要注意，从管道中取出的是空接口，需要使用类型断言来进行类型的转换
num := <-channel

// 关闭管道
// 关闭后就不能再写入数据了
// 再管道中所有数据都取出后，管道被销毁
close(channel)

// 管道支持for-range遍历
// 这里是取，而不是单纯的遍历
// 但必须要先关闭管道
for val := range channel{
    fmt.Println(val)
} 
```

