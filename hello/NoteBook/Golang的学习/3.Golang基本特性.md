# 三. Golang基本特性

-----

[toc]

-----

## 1. 函数

### (1). 函数的定义

```go
func 函数名 (形参列表)(返回值类型列表){
    // 代码块
    return 返回值列表
}
// 函数可以没有返回值，对应的就是空出返回值类型列表
// 返回值类型列表可以加上变量名也可以不加（加上变量名则相当于进行了变量的声明）
// go语言也是传值调用的

// 在接收返回值时，需要数量相同并且类型一致的若干变量来接收
```

### (2). Golang函数的特性

​		函数可以没有返回值，对应的就是空出返回值类型列表

​		返回值类型列表可以加上变量名也可以不加（要统一）

​		go语言也是传值调用的

```go
// 函数的返回值列表
func getSomeNum() (int, int, int, int) {
	return 1, 2, 3, 4
}
num1, num2, num3, num4 := getSomeNum()
fmt.Println(num1, num2, num3, num4)
```

​		在接收返回值时，需要数量相同并且类型一致的若干变量来接收，或者使用下划线_来忽略其中的若干返回值。

​		首字母大写的函数可以被包外部通过包进行访问，类似public，否则只能在包内部使用，类似private。

​		Golang函数不支持重载。

​		在Golang中，函数也是一种数据类型，可以作为形参进行访问。

```go
// 函数作为形参进行传入调用
// 在进行调用时，就可以传入一个满足相同函数类型的函数来在这个函数内部进行调用
func function1(aFunc func(int) int, num int) int {
	return aFunc(num)
}
// 这样写会很繁琐，Golang也提供了自定义数据类型
// 下面的代码就将一个函数类型定义为myfunc类型，可以直接使用
type myfunc func(int, int)(int)
```

​		Golang支持可变参数

```go
func function(arg... int) int{
    // 形参列表中的arg...代表零到多个参数
}
func function(num int, arg... int) int{
    // 这样则代表一到多个参数
}
// arg是一个slice（切片），可以通过下标访问其中的各个元素

// eg:
// 求一到多个参数的和
func getSumFromNums(num1 int, arg ...int) (sum int) {
	sum = num1
	for i := 0; i < len(arg); i++ {
		sum += arg[i]
	}
	return sum
}
```

### (3). init函数

​		==每一个源文件（不分包）==中都可以包含一个init函数，这个/些函数会在main函数执行前被调用。

​		如果一个源文件同时包含全局变量定义，init函数和main函数。那么执行的流程是：==全局变量定义 -> init函数 -> main函数==。导入的其他包中的全局变量定义和init函数的执行也是如此。

### (4). 匿名函数

​		Golang支持匿名函数，如果一个函数只需要被显式地使用一次，那么可以不给这个函数命名，将其定义为一个匿名函数。即，在函数的定义时，就完成调用。语法如下：

```go
// 个人认为匿名函数一般在函数传参处会比较灵活，可以类比Java中的静态内部类传入方法
// 求两个数的和的匿名函数
num := func(num1 int, num2 int) int {
    return num1 + num2
}(1, 2)
fmt.Println(num)

// 在函数内通过匿名函数定义一个函数，这样就将作用域限制为外层的函数
get1 := func() int {
    return 1
}
fmt.Println(get1())
```

### (5). 函数的闭包

```go
// 函数的闭包
// 累加器
// 这里返回的是一个函数，其具体的定义是内部的匿名函数
// 但在这个匿名函数内引用了外部的变量count，就形成了闭包
// 也就是说，匿名函数可以引用其外部的变量，并和这些外部变量共同组成一个闭包
// 可以理解为整个闭包是一个对象，这个函数是其中的方法，变量则担任成员变量的指责
// 这里的addCount函数只进行了一次，所以count变量只会被初始化一次，后边被内部的方法修改
// 生成新的方法也不会影响原先的方法的闭包
func addCount() func(int) int {
    var count int = 0
    return func(num int) int {
        count += num
        return count
    }
}
func main(){
    fun1 := addCount()
    fmt.Println(fun1(1))
    fmt.Println(fun1(1))
    fmt.Println(fun1(1))
    fmt.Println(fun1(1))
    fmt.Println(fun1(1))
}
// ------------------------------------
// 1
// 2
// 3
// 4
// 5
```

### (6). defer机制

​		Go语言提供一种在函数执行完进行一一系列操作的机制，被称为defer（延时机制）。可以用来进行资源的释放等操作，可以类比Java中的finally关键字的使用。

```go
// defer机制
// 在函数中前面标有defer关键字的语句会被压入defer栈
// 在函数执行完之后，会从defer栈中一条一条的取出语句来执行
// 因为是栈，所以要注意defer语句执行的顺序
// 这里使用栈的原因，个人觉得是考虑到资源的释放需要从下向上进行释放
// 需要注意的是，defer语句中的变量，是一个快照，不会受后面语句的影响而输出不同的结果
func deferDemo() int {
	defer fmt.Println("defer 1")
	defer fmt.Println("defer 2")
	fmt.Println("do 1")
	return 1
}
func main(){
    fmt.Println(deferDemo())
}
// ----------------------------------
// do 1
// defer 2
// defer 1
// 1
```



## 2. Golang中的包机制

​		在Golang中，使用包这一概念来对函数和变量进行分隔。

​		通常将完成某一功能的变量和功能放在一个包中，外部通过包去访问内部的函数，从而进行有效的管理。

​		也可以理解为一种命名空间。

​		在Golang中，完整包名是从$GOPATH下的src开始一直找到这个包的最底层目录，之间使用‘/’进行分隔。

​		在使用包中的变量或者函数时，使用package.function()的形式去调用。

​		可以使用如下方法给包起别名，来简便开发。

```go
// 给包起别名
// 也可以给多个包起一个别名，降低区分度，简化开发
import pkg "package"
```

> 关于包名的一些规范；
>
> ​		一个目录中只能存在一个以目录名为包名的包或者一个main包，每一个 main包的源文件 都可以存在一个main函数，可以理解为程序的入口。但每次只能选择其中的一个进行编译。
>
> ​		一般来说，一个程序在最顶层有一个main包，下面有main包的源文件和main函数。其他目录都只能存在一个包，并且源文件的包名都需要和目录名一致

## 3. 常用系统函数

### (1). 字符串

```go
// 统计字符串（或者其他类似的类型）长度
len(str)
// 字符串的遍历（处理中文）这里可以理解为强转，当然也可以转数组类型）
r := []rune(str)
// 字符串转整数
n, err := strconv.Atoi("123")
// 整数转字符串
str := strconv.Itoa(123)
// 十进制转2，8，16进制字符串
str := strconv.FormatInt(123, 2)
// 查找字符串str中是否存在子串s
boolean := strings.Contains(str, s)
// 返回字符串str中第一次出现子串s的下标
index := strings.Index(str, s)
// 将字符串str中的子串s1全部换成字符串s2
strings.Replace(str, s1, s2)
```

### (2). 时间和日期

​		time包是go语言系统库提供的时间和日期处理包。

```go
// time.Time类型，用于表示时间
// 获取当前时间
now = time.Now()
// 获取其他日期信息
year = now.Year()
month = now.Month()
day = now.Day()
hour = now.Hour()
minute = now.Minute()
sesond = now.Secons()
now := time.Now()

// 测试time包中的时间格式化
// 方式一：使用fmt.Sprintf("格式"，参数)来进行格式化填充
fmt.Printf("%d-%d-%d %d:%d:%d\n", now.Year(), now.Month(), now.Day(),
           now.Hour(), now.Minute(), now.Second())
// 方式二：使用time.Time对象的Format方法进行格式化
// 其中 2006，1，2，15，4，5这些数组都是固定代表某一个时间属性的，类比Java中的YYYY等等
timeStr := now.Format("2006/01/02 15:04:05")
fmt.Println(timeStr)
```

### (3). 内置函数

​		不需要导包，可以直接使用的函数。

```go
// 求数组或切片等等数据结构的长度
len()
// 分配内存，和Java中的new完全不一样，相当于C中的malloc
// 区别是分配出的空间其内部是有默认值的
// 返回的是一个指针
// 主要是给引用类型使用的
num := new(int)
```

