

# 第10章 Java并发包中线程同步器原理剖析

------

[TOC]

------

## 1. CountDownLatch原理剖析

###  (1). 介绍

​		日常开发中经常碰到等待其他线程运行结束的情况,之前学习的方法中,可以使用Thread.join()方法实现,但是有很多局限性,且不够灵活.

​		使用CountDownLatch可以更好的实现这个功能.

```Java
// new一个CountDownLatch对象,传入参数为要监控的线程数.
CountDownLatch countDownLatch = new CountDownLatch(2);

// 主线程(或者灵活的选择使用场景)中使用,会挂起当前线程,知道CountDownLatch对象的计数器为0
countDownLatch.await();

// 在子线程中使用,CountDownLatch的计数器会减一,当计数器为0时,
countDownLatch.countDown();
```

它的优点有:

-   更灵活:可以再子线程的任意处位置让程序计数器自减.
-   更实用:在线程池开发中,通常不会直接操作线程对象传入的都是Runnable或者Callable对象,没有join()方法可以调用.而CountDownLatch的使用不受影响.

### (2). 实现原理

#### 1). 结构

​		内部使用AQS实现,计数器的值被赋给了AQS的状态变量state.

#### 2). void await()方法

当CountDownLatch对象调用await()方法后,当前线程或被阻塞,知道下面的情况才会返回:

-   所有线程都调用了CountDownLatch对象的countDown()方法,也就是说计数器的值为0时.
-   其他线程调用了当前线程的interrupt()方法中断了当前线程,该方法会抛出InterruptedException异常后返回.

```Java
public void await() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}
// 响应中断的共享锁
public final void acquireSharedInterruptibly(int arg) throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    // state若不为0,进入AQS队列等待
    if (tryAcquireShared(arg) < 0)
        doAcquireSharedInterruptibly(arg);
}
protected int tryAcquireShared(int arg) {
    return (getState() == 0) ? 1 : -1;
}
```

#### 3). boolean await(long timeout, TimeUnit unit)方法

​		与上一个类似,但是当设置的timeout时间到了,会因为超时返回false.

```Java
public boolean await(long timeout, TimeUnit unit) throws InterruptedException {
    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
}
```

#### 4). void countDown()方法

```Java
public void countDown() {
    sync.releaseShared(1);
}
public final boolean releaseShared(int arg) {
    // 设置state--
    if (tryReleaseShared(arg)) {
        // 上一步操作成功,则说明state已经为0,释放资源(AQS队列首元素啥的)
        doReleaseShared();
        return true;
    }
    return false;
}
protected boolean tryReleaseShared(int releases) {
    for (;;) {
        // 获取state,如果为0,则不需要在释放资源了,返回false
        // 防止计数器为零后,其他线程仍然调用,使计数器为负数
        // 否则state--(自旋+CAS操作)
        int c = getState();
        if (c == 0)
            return false;
        int nextc = c-1;
        if (compareAndSetState(c, nextc))
            return nextc == 0;
    }
}
```

#### 5). long getCount()方法

```Java
public long getCount() {
    return sync.getCount();
}
int getCount() {
    return getState();
}
```

## 2. 回环屏障CyclicBarrier原理探究

### (1). 介绍

​		CountDownLatch的计数器是一次性的,也就是说等计数器的值为0时,在调用await和countDown方法都会立刻返回,起不到线程同步的效果了.

​		为了满足计数器可以重置的需要,JDK提供了CyclicBarrier类,功能并不局限于CountDownLatch的功能.

​		从字面意思理解,CyclicBarrier是回环屏障的意思,它可以让一组线程全部达到一个状态后在全部同时执行.当所有等待线程执行完毕并重置CyclicBarrier的状态后,它可以被重用.

​		之所以被叫做屏障是因为调用await方法后会被阻塞,这个阻塞点被称为屏障点,等所有线程都调用了await方法后,线程们就会冲破屏障,继续向下运行.

```Java
public class Demo {
    // 创建一个CyclicBarrier实例,添加一个当所有线程冲破屏障后都会执行的方法
    private static CyclicBarrier cyclicBarrier = new CyclicBarrier(2, new Runnable() {
        @Override
        public void run() {
            System.out.println("ok ok");
        }
    });

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(2);
        // 线程池中添加两个任务
        executorService.submit(new Runnable() {
            @Override
            public void run() {
                try {
                    System.out.println("A1");
                    // 执行完await方法后会等待其他线程
                    // 当所有线程都执行之后,会执行传入cyclicBarrier对象的方法
                    cyclicBarrier.await();
                    System.out.println("A2");
                    cyclicBarrier.await();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });
        executorService.submit(new Runnable() {
            @Override
            public void run() {
                try {
                    System.out.println("B1");
                    cyclicBarrier.await();
                    System.out.println("B2");
                    cyclicBarrier.await();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });
		executorService.shutdown();
    }
    
}

/////////////////////////////执行结果///////////////////////////////////
A1
B1
ok ok
B2
A2
ok ok
```

### (2). 实现原理

#### 1). 结构

​		CyclicBarrier基于独占锁实现,本质底层还是AQS的.

​		parties用来记录线程个数,表示当多少线程调用了await()方法后,所有线程才会冲破屏障.是构造器中第一个参数.

​		count记录当前await()方法的调用数,一开始等于parties.这里使用两个值存储的意图在于实现复用.