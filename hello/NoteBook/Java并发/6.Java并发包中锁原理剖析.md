# 第6章 Java并发包中锁原理剖析

------

[TOC]

------

## 1. AQS-----锁的底层支持

​		**<u>AbstractQueuedSynchronizer抽象同步队列简称AQS,是实现同步器的基础组件</u>**,并发包中锁的底层就是使用AQS实现的.

​		**<u>AQS是一个FIFO的双向队列,队列元素为Node. Node中的thread用来存放进入AQS队列的线程.Node节点内部waitStatus记录当前线程等待状态:CANCELLED(1,线程被取消),SIGNAL(-1,线程需要被唤醒),CONDITION(-2,线程在条件队列中等待),PROPAGATE(-3,释放共享资源时需要通知其他节点).</u>**

![waitStatus状态值](https://img-blog.csdn.net/20170902171807640)

​		AQS中维持了一个单一的状态信息state,可以通过CAS操作修改其值,并且它有get()和set()方法.

​		对于AQS来说,线程同步的关键对状态值state进行操作,分为独占方式(标记,如果标记状态不正确不能进行操作)和共享方式(直接进行CAS修改,不需要判断标记).

### (1). 独占不响应中断模式下,获取与释放资源

[AbstractQueuedSynchronizer源码剖析（二）- 不响应中断的独占锁](https://blog.csdn.net/pfnie/article/details/77802229)

#### 1). 获取锁的过程

```java
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

private Node addWaiter(Node mode) {
    //基于当前线程，节点类型（Node.EXCLUSIVE）创建新的节点
    //由于这里是独占模式，因此节点类型就是Node.EXCLUSIVE
    Node node = new Node(Thread.currentThread(), mode);
    Node pred = tail;
    //这里为了提搞性能，首先执行一次快速入队操作，即直接尝试将新节点加入队尾
    if (pred != null) {
        node.prev = pred;
        //这里根据CAS的逻辑，即使并发操作也只能有一个线程成功并返回，其余的都要执行后面的入队操作。即enq()方法
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    enq(node);
    return node;
}

private Node enq(final Node node) {
    for (;;) {
        Node t = tail;
        //如果队列还没有初始化，则进行初始化，即创建一个空的头节点
        if (t == null) { 
            //同样是CAS，只有一个线程可以初始化头结点成功，其余的都要重复执行循环体
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            //新创建的节点指向队列尾节点，毫无疑问并发情况下这里会有多个新创建的节点指向队列尾节点
            node.prev = t;
            //基于这一步的CAS，不管前一步有多少新节点都指向了尾节点，这一步只有一个能真正入队成功，其他的都必须重新执行循环体
            if (compareAndSetTail(t, node)) {
                t.next = node;
                //该循环体唯一退出的操作，就是入队成功（否则就要无限重试）
                return t;
            }
        }
    }
}

final boolean acquireQueued(final Node node, int arg) {
    //锁资源获取失败标记位
    boolean failed = true;
    try {
        //等待线程被中断标记位
        boolean interrupted = false;
        //这个循环体执行的时机包括新节点入队和队列中等待节点被唤醒两个地方
        for (;;) {
            //获取当前节点的前置节点
            final Node p = node.predecessor();
            //如果前置节点就是头结点，则尝试获取锁资源
            if (p == head && tryAcquire(arg)) {
                //当前节点获得锁资源以后设置为头节点，这里继续理解我上面说的那句话
                //头结点就表示当前正占有锁资源的节点
                setHead(node);
                p.next = null; //帮助GC
                //表示锁资源成功获取，因此把failed置为false
                failed = false;
                //返回中断标记，表示当前节点是被正常唤醒还是被中断唤醒
                return interrupted;
            }
            //如果没有获取锁成功，则进入挂起逻辑
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        //最后会分析获取锁失败处理逻辑
        if (failed)
            cancelAcquire(node);
    }
}

//首先说明一下参数，node是当前线程的节点，pred是它的前置节点
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    //获取前置节点的waitStatus
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL)
        //如果前置节点的waitStatus是Node.SIGNAL则返回true，然后会执行parkAndCheckInterrupt()方法进行挂起
        return true;
    if (ws > 0) {
        //由waitStatus的几个取值可以判断这里表示前置节点被取消
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus > 0);
        //这里我们由当前节点的前置节点开始，一直向前找最近的一个没有被取消的节点
        //注，由于头结点head是通过new Node()创建，它的waitStatus为0,因此这里不会出现空指针问题，也就是说最多就是找到头节点上面的循环就退出了
        pred.next = noparkAndCheckInterrupt()de;
    } else {
        //根据waitStatus的取值限定，这里waitStatus的值只能是0或者PROPAGATE，那么我们把前置节点的waitStatus设为Node.SIGNAL然后重新进入该方法进行判断
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
```



1.  当前线程调用acquire()申请获取锁资源
    1.  先调用tryAcquire()尝试获取锁()
        1.  这个方法内部由具体的锁实现
    1.  如果失败先调用addWaiter()将当前线程入队到AQS队列中
        1.  如果之前没有创建队列(队尾为null),直接调用enq进行完整的入队操作(包括初始化)
            1.  是一个自旋循环,第一次循环创建一个空结点,设置为队尾和队首,第二次循环时将传入的node入队
        1.  如果已经有队尾存在了,先将node(待插入结点)的前置设置为tail,使用t指针指向tail,使用CAS将tail指针指向node,然后将实际上的队尾t的next设置为node.
    1.  然后在acquireQueued()方法中等待被唤醒直到获取到资源.
        1.  进入acquireQueued方法后会进入一个无限循环.每一次循环都会判断传入的参数是不是队首,并且尝试一次锁获取
        1.  如果获取成功,将自己设置为队首,并将node.thread设置为null,保证头结点永远是一个不带thread的空节点.
        1.  如果获取失败,调用shouldParkAfterFailedAcquire()判断自己需不需要阻塞.阻塞的大前提是前继节点是可被唤醒的(waitStatus设置为Signal),这样才能让自己有机会被唤醒(队列中按顺序唤醒)
            1.  判断传入的前继节点的waitStatus是否为Signal,是的话直接返回ture
            1.  根据waitStatus的值分为两种情况
            1.  如果waitStatus大于0:也就是前继节点被取消了.一直向前查找一个没有被取消的节点(waitStatus>=0)的结点(头结点waitStatus为0或-1,因此不可能出现空指针),并拼接成双向队列(**<u>后面的队列都是waitStatus>=0的,在状态表中只有被取消的线程是这个状态,所以被移除出队列,下一次GC会被清除</u>**),返回false
            1.  如果waitStatus不大于0,也就是为0,-2或-3:修改前继节点waitStatus为-1
        1.  如果shouldParkAfterFailedAcquire()返回true,证明node的前继节点可以被唤醒,立即调用parkAndCheckInterrupt()阻塞挂起node
        1.  如果shouldParkAfterFailedAcquire()返回false,证明在方法内部找到了一个可以被唤醒的节点作为前继节点.在下一次循环中进行挂起
        1.  parkAndCheckInterrupt()方法的挂起并不会被中断打断,是非中断挂起,如果挂起过程中出现了中断,方法在返回时会返回true,否则返回false
        1.  如果上一步返回了true,证明出现了中断,在下一次循环中将中断标记返回到上一层代码.
    1.  线程被唤醒之后会将返回中断标记到这里,如果出现过中断,将自身线程挂起,来弥补之前的中断.
1.  进入临界区(线程中运行的用户代码)

####  2). 锁的释放过程

```java
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}

private void unparkSuccessor(Node node) {
    int ws = node.waitStatus;
    if (ws < 0)
        //把标记为设置为0，表示唤醒操作已经开始进行，提高并发环境下性能
        compareAndSetWaitStatus(node, ws, 0);

    Node s = node.next;
    //如果当前节点的后继节点为null，或者已经被取消
    if (s == null || s.waitStatus > 0) {
        s = null;
        //注意这个循环没有break，也就是说它是从后往前找，一直找到离当前节点最近的一个等待唤醒的节点
        for (Node t = tail; t != null && t != node; t = t.prev)
            if (t.waitStatus <= 0)
                s = t;
    }
    //执行唤醒操作
    if (s != null)
        LockSupport.unpark(s.thread);
}
```

释放锁的逻辑并不复杂.

1.  调用tryRelease()来释放资源.(判断当前线程是否和AQS中的线程一致,然后对state进行修改)(这里返回值是指是否已经完全释放资源了,可重入锁需要将state释放至0)
1.  拿到head节点,判断其状态,如果不为null,且waitStatus不为0(初始状态下,为0,当这个节点有了后继节点时,会被修改成-1,这里是为了防止只有一个头节点的空队列进行了释放锁),调用unparkSuccessor()唤醒头结点的后继节点的线程
    1.  先进行waitStatus的判断,如果waitStatus<0,将其设置为0,避免其他线程也进入此方法,提高高并发环境下的性能.
    1.  找到头结点的后继节点,再次判断是否为空或者其状态值是否被取消
    1.  如果后继节点为空或者状态为被取消,从后向前找到最前面的一个等待唤醒的节点
    1.  执行唤醒操作
1.  返回true

​		如果唤醒的节点前有被取消的节点,那么会在唤醒后被判断前继节点不是头结点,再次进行判断前继节点是否能被唤醒的方法调用.在这个方法调用中会将前面的被取消的节点移除,然后再次进行前继节点是不是头结点的判断.这次就可以判断成功,将此节点设置为头结点,成功唤醒,运行其内部用户代码.

### (2). 共享不响应中断模式下,获取与释放资源

[AbstractQueuedSynchronizer源码剖析（四）- 不响应中断的共享锁](https://blog.csdn.net/pfnie/article/details/77816882)

#### 1). 获取锁的过程

```Java
public final void acquireShared(int arg) {
    //尝试获取共享锁，返回值小于0表示获取失败
    if (tryAcquireShared(arg) < 0)
        //执行获取锁失败以后的方法
        doAcquireShared(arg);
}

//参数不多说，就是传给acquireShared()的参数
private void doAcquireShared(int arg) {
    //添加等待节点的方法跟独占锁一样，唯一区别就是节点类型变为了共享型，不再赘述
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            //表示前面的节点已经获取到锁，自己会尝试获取锁
            if (p == head) {
                int r = tryAcquireShared(arg);
                //注意上面说的， 等于0表示不用唤醒后继节点，大于0需要
                if (r >= 0) {
                    //这里是重点，获取到锁以后的唤醒操作，后面详细说
                    setHeadAndPropagate(node, r);
                    p.next = null;
                    //如果是因为中断醒来则设置中断标记位
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            //挂起逻辑跟独占锁一样，不再赘述
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        //获取失败的取消逻辑跟独占锁一样，不再赘述
        if (failed)
            cancelAcquire(node);
    }
}

//两个入参，一个是当前成功获取共享锁的节点，一个就是tryAcquireShared方法的返回值，注意上面说的，它可能大于0也可能等于0
private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head; //记录当前头节点
    //设置新的头节点，即把当前获取到锁的节点设置为头节点
    //注：这里是获取到锁之后的操作，不需要并发控制
    setHead(node);
    //这里意思有两种情况是需要执行唤醒操作
    //1.propagate > 0 表示调用方指明了后继节点需要被唤醒
    //2.头节点后面的节点需要被唤醒（waitStatus<0），不论是老的头结点还是新的头结点
    if (propagate > 0 || h == null || h.waitStatus < 0 ||
        (h = head) == null || h.waitStatus < 0) {
        Node s = node.next;
        //如果当前节点的后继节点是共享类型或者没有后继节点，则进行唤醒
        //这里可以理解为除非明确指明不需要唤醒（后继等待节点是独占类型），否则都要唤醒
        if (s == null || s.isShared())
            //后面详细说
            doReleaseShared();
    }
}

private void setHead(Node node) {
    head = node;
    node.thread = null;
    node.prev = null;
}
```

1.  调用acquireShared()去获取锁
    1.  首先会尝试调用tryAcquireShared()共享方式获取资源,返回值负数表示失败,0表示成功,但没有剩余资源可用,整数表示成功且有剩余资源
    1.  当返回负数时,调用doAcquireShared()进行线程的入队列挂起等待
        1.  将当前线程打包成Node对象,类型为共享型,添加到队列尾,方法与独占式相同
        1.  如果当前节点的前继节点是头结点,尝试进行获取资源,如果返回值不为负,意味着可以获取到资源,调用setHeadAndPropagate()将当前节点设置为头结点,判断是否是因为唤醒线程来到这里,对中断标记进行判断,是否进行中断补充
            1.  setHeadAndPropagate(Node node, int propagate)的第二个参数是刚刚尝试获取资源得到的剩余资源数,如果大于零,代表有多余资源,那么应该去唤醒下一个可被唤醒的线程
            1.  h == null 场景未知,应该不会出现吧.
            1.  h.waitStatus意味着头结点为可唤醒状态
            1.  以上的集中状况都需要进行线程唤醒的尝试.如果当前头结点的前继节点不为空且为共享型,调用doReleaseShared()对头结点后的第一个可唤醒节点进行唤醒.
        1.  如果前继节点不是头节点,挂起,逻辑同独占锁

#### 2). 释放锁的过程

```Java
public final boolean releaseShared(int arg) {
    //尝试释放共享锁
    if (tryReleaseShared(arg)) {
        //唤醒过程，详情见上面分析
        doReleaseShared();
        return true;
    }
    return false;
}

private void doReleaseShared() {
    for (;;) {
        //唤醒操作由头结点开始，注意这里的头节点已经是上面新设置的头结点了
        //其实就是唤醒上面新获取到共享锁的节点的后继节点
        Node h = head;
        if (h != null && h != tail) {
            int ws = h.waitStatus;
            //表示后继节点需要被唤醒
            if (ws == Node.SIGNAL) {
                //这里需要控制并发，因为入口有setHeadAndPropagate跟release两个，避免两次unpark
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;      
                //执行唤醒操作      
                unparkSuccessor(h);
            }
            //如果后继节点暂时不需要唤醒，则把当前节点状态设置为PROPAGATE确保以后可以传递下去
            else if (ws == 0 &&
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                
        }unparkSuccessor
        //如果头结点没有发生变化，表示设置完成，退出循环
        //如果头结点发生变化，比如说其他线程获取到了锁，为了使自己的唤醒动作可以传递，必须进行重试
        if (h == head)                   
            break;
    }
}
```

1.  调用releaseShared()获取资源
    1.  先调用tryReleaseShared()尝试释放共享锁,由具体的锁实现逻辑,如果获取到了资源,返回true.继而调用doReleaseShared()唤醒头结点后的可唤醒线程
        1.  进入一个自旋循环
        1.  判断头结点(如果从设置头结点调用至此方法,此时头结点是新的头节点)是否为空,是否只有一个头结点组成空队列.
        1.  如果都不是,那么头结点有效,然后判断头结点状态,如果为-1,设置为0,
        1.  调用unparkSuccessor()执行唤醒操作(别的线程在21行会判断为true,跳过,这样就控制了并发)
            1.  unparkSuccessor()与独占锁相同,如果头结点的后继节点不能唤醒,从后向前找到最前面的一个等待唤醒的节点唤醒它
        1.  然后跳入27行将状态改为共享模式下可释放,适应在设置头结点处的调用.
        1.  如果头结点没有变化(并发情况下,其他线程可能会改变head的引用),退出方法.