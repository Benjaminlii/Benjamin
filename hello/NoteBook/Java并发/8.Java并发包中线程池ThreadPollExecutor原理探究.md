# 第8章 Java并发包中线程池ThreadPoolExecutor原理剖析

------

[TOC]

------

[JDK1.7中的ThreadPoolExecutor源码剖析](https://blog.csdn.net/liuguangqiang/article/details/52169926)

## 1. 介绍

线程池主要解决两个问题:

1.  当执行大量异步任务是线程池能提供良好的性能,如果不使用线程池,每当需要执行异步任务时直接new一个线程来运行,需要很大的开销.
1.  线程池提供了一种资源限制和管理的手段,比如限制线程的个数,动态新增线程等.

## 2. 结构组成

​		Executors实际上是一个工具类,里面提供了很多静态方法,这些方法根据用户选择返回不同的线程池实例.

​		成员变量ctl是一个Integer的原子变量,用来记录线程池状态和线程池中线程的个数(高3位用来表示线程池状态,低29位用来表示线程个数).

### (1). 线程池状态

-   RUNNING(111):接受新任务并处理阻塞队列里的任务
-   SHUTDOWN(000):拒绝新任务,但是处理阻塞队列中的任务
-   STOP(001):拒绝新任务并且抛弃阻塞队列里的任务,同时会中断正在处理的任务
-   TIDYING(010):所有任务都执行完之后当前线程池活动线程数为0,将调用terminated()方法
-   TERMINATED(011):终止状态,调用terminated()方法并完成后的状态.

### (2). 线程转换

-   RUNNING ---> SHUTDOWN:调用shutdown()方法
-   RUNNING或SHUTDOWN ---> STOP:调用shutdownNow()方法
-   SHUTDOWN ---> TIDYING:线程池和任务队列都为空
-   TIDYING ---> TERMINATED:当terminated()hook方法执行完成时

### (3). 线程池参数

-   corePoolSize:线程池核心线程个数
-   workQueue:等待执行的任务的阻塞队列
-   maximunPoolSize:最大线程数量
-   ThreadFactory:创建线程的工厂
-   keeyAliveTime:存活时间

### (4). 线程池类型

-   newFixedThreadPoll:带参数构造,参数为核心线程数和最大线程数,阻塞队列长度为Integer.MAX_VALUE
-   newSingleThreadExecutor:核心线程数和最大线程数都为1,但是阻塞队列长度为Integer.MAX_VALUE
-   newCachedThreadPoll:按需创建线程,初始个数为0,最多为Integer.MAX_VALUE,根据线程存活时间进行回收,特殊点在于加入同步队列的任务马上就会被执行,同步队列最多只能有一个元素.

### (5). 其他

-   mainLock是独占锁,用来空值Worker线程操作的原子性
-   termination是该锁对应的条件队列
-   Worker继承AQS和Runnable接口,是具体承载任务的对象.继承了AQS,内部实现了简单的不可重入锁,其中state=0表示锁空闲,state=1表示锁被占用.state=-1是创建时的默认状态,为了避免才运行runWorker()方法时被中断.

## 3. 源码分析

### (1). public void execute(Runnable command)

​		提交任务command带线程池进行执行.

```Java
public void execute(Runnable command) {
    // 如果传入的任务为空,抛出异常
    if (command == null)
        throw new NullPointerException();
    // 获取线程池的状态和线程数量
    int c = ctl.get();
    // 线程池未满,则添加新线程并更新.addWorker()方法在后面讲解.
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    // 如果线程处于RUNNING状态,将任务添加到阻塞队列
    if (isRunning(c) && workQueue.offer(command)) {
        // 检查任务添加到阻塞队列后的线程池状态
        int recheck = ctl.get();
        // 如果这时线程池状态改变了,删除刚刚添加的任务,并执行拒绝策略
        if (! isRunning(recheck) && remove(command))
            reject(command);
        // 如果线程池状态没有改变,但是为空,添加一个线程
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    // 如果线程不是RUNNING状态或者添加任务失败,都说明阻塞队列已满
    // 尝试开启一个新线程,如果失败就执行拒绝策略
    else if (!addWorker(command, false))
        reject(command);
}

// core如果为true，请使用corePoolSize(核心线程数)作为绑定，否则使用maximumPoolSize(最大线程数)。
// 代码很长,其实就做了两件事。
//     1）才用循环CAS操作来将线程数加1；
//     2）新建一个线程并启用。
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    // 第一部分 循环CAS操作，将线程池中的线程数+1.
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
		// 检查队列的状态是否是非RUNNING状态
        // 是SHUTDOWN状态时  传入的任务不为空 或 工作队列为空
        // 如果符合以上描述,返回false
        // 因为SHUTDOWN状态下不接受新任务,且当工作队列为空时说明阻塞队列也为空了,这是会转换成TIDYING状态
        if (rs >= SHUTDOWN &&
            !(rs == SHUTDOWN && firstTask == null && !workQueue.isEmpty()))
            return false;

        // 自旋增加线程个数
        for (;;) {
            int wc = workerCountOf(c);
            // 线程个数超限返回false
            // CAPACITY最大线程个数,极限值,非用户定义
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            // CAS增加线程个数,只能有一个线程成功,成功的线程进入下一块内容
            if (compareAndIncrementWorkerCount(c))
                break retry;
            // 没成功的线程查看线程池状态是否发生变化
            // 如果发生变化,调到外层循环重新获取线程状态
            // 如果没有变化,内层自旋
            c = ctl.get();
            if (runStateOf(c) != rs)
                continue retry;
        }
    }

    // 第二部分 新建线程，并加入到线程池workers中。
    // 能运行到这里说明CAS操作成功了,
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        // 封装任务为Worker对象,并抽取出线程
        w = new Worker(firstTask);
        final Thread t = w.thread;
        // 上一步成功执行if块内的代码
        // 否则返回false
        if (t != null) {
            // 上锁
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // 重新获取线程池状态
                int rs = runStateOf(ctl.get());
				// 如果当前线程是RUNNABLE状态  或者  是SHUTDOWN状态但传入的任务为空
                if (rs < SHUTDOWN || (rs == SHUTDOWN && firstTask == null)) {
                    // 判断添加的任务状态,如果已经开始丢出异常(外部手动启动线程)
                    if (t.isAlive())
                        throw new IllegalThreadStateException();
                    // 将新建的线程加入到线程池中
                    workers.add(w);
                    int s = workers.size();
                    // 修正最大池深度的值
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                // 解锁
                mainLock.unlock();
            }
            // 添加任务成功就启动任务
            if (workerAdded) {
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

![addWorker方法流程图](https://img-blog.csdn.net/20180317162304697)

### (2). 工作线程Worker的执行

​		用户提交任务到线程池之后,是由Worker来执行的.

​		Worker相当于一个自己带锁的线程.

```Java
// Worker的构造方法
Worker(Runnable firstTask) {
    // 现将state设置为-1是防止在运行前被中断(shutdownNow方法中断所有线程).
    setState(-1);
    this.firstTask = firstTask;
    // 由工厂生产线程
    this.thread = getThreadFactory().newThread(this);
}

// 执行任务
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    // 将state设置为0,允许中断
    w.unlock();
    boolean completedAbruptly = true;
    try {
        // 当前Worker的调度任务不为空  或者  能获取到任务
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // 线程池处于STOP状态  或者  当线程被中断时处于STOP状态
            // 但是现在并没有被中断
            // 处于以上情景时,发出中断请求
            // 总结就是处理中断
            if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP)))
                && !wt.isInterrupted())
                wt.interrupt();
            // 执行扩展接口代码
            try {
                // 开始执行任务前的Hook(钩子)
                // 在本类中为空实现,可以在子类中加入诸如事务控制之类的动作
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();
                    // 发现异常就向上一层抛出
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    // 同上
                    afterExecute(task, thrown);
                }
            } finally {
                // 每次运行完任务,将任务标记为null,并计数
                task = null;
                w.completedTasks++;
                // 解锁
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        // completedAbruptly为true,说明之前抛出异常了,会进行清理工作
        processWorkerExit(w, completedAbruptly);
    }
}
// 该方法源源不断的(从等待队列中)向Worker输入任务
private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
        // 获取线程池状态
        int c = ctl.get();
        int rs = runStateOf(c);

        // 如果线程池状态为SHUTDOWN时队列为空 或者 为STOP或TERMINATE状态
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            // 回收线程,线程数量-1
            decrementWorkerCount();
            return null;
        }

        // 重新得到线程数
        int wc = workerCountOf(c);

        // 标识,含义为当前线程空闲,应该回收
        // allowCoreThreadTimeOut含义:
        //     该值为true，则线程池数量最后销毁到0个。
        //     该值为false，超过核心线程数时，而且（超过最大值或者timeout过），就会销毁。
        // 当线程数超过核心线程池大小 或者 销毁机制为销毁到0(可能跟STOP状态有关) 时,回收该线程
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

        // 如果线程数超过线程池大小 || (标识为应该回收 && 还有work可以获取)&&(有线程 || work队列飞控)
        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            // 注:poll不阻塞,take阻塞
            // 当标记为清除时,尝试获取一个Worker,否则阻塞获取一个Worker
            Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
            workQueue.take();
            // r!=null 说明标记为不清除,而且得到了work
            if (r != null)
                return r;
            // r==null 说明没有获得work   队列为空了  没有work可以获取了
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
private void processWorkerExit(Worker w, boolean completedAbruptly) {
    if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted
        decrementWorkerCount();

    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        completedTaskCount += w.completedTasks;
        workers.remove(w);
    } finally {
        mainLock.unlock();
    }

    tryTerminate();

    int c = ctl.get();
    if (runStateLessThan(c, STOP)) {
        if (!completedAbruptly) {
            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
            if (min == 0 && ! workQueue.isEmpty())
                min = 1;
            if (workerCountOf(c) >= min)
                return; // replacement not needed
        }
        addWorker(null, false);
    }
}
```

