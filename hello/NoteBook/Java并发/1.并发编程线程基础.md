# 第1章 并发编程线程基础

------

[TOC]

------

## 1. 什么是线程

​		进程是代码在数据集合上的依次运行活动,是系统进行资源分配和调度的基本单位.线程则是进程的一个执行路径,一个进程中至少一个线程.进程中的多个线程共享进程的资源.

​		操作系统在分配资源时是把资源分配给进程的,但是CPU资源是被分配给线程的.

​		一个进程中有多个线程,多个线程共享进程的**<u>堆</u>**(存放对象实例)和**<u>方法区</u>**(类,常量和静态变量),每个线程有自己的**<u>程序计数器</u>**(记录下一步要执行的指令地址,用于记录当前线程执行的位置)和**<u>栈</u>**区域(储存该项成的局部变量,和方法调用帧栈).

## 2. 线程创建与运行

​		Java有三种创建线程的方式,分别为**<u>实现Runnable接口的Run方法</u>**(将接口对象传入Thread对象,运行Thread对象的start()方法),**<u>继承Thread类</u>**(执行start()方法)和**<u>FutureTask方式</u>**(实现Callable<E>接口,泛型E为线程返回值的类型,将接口实例对象传入FutrueTask对象,再将FutrueTask对象传入Thread对象,执行start方法).

FutureTask方式:

```Java
public class CallerTask implements Callable<String>{

        @Override
        public String call() throws Exception {
            System.out.println("child thread");
            return "hello";
        }

        public static void main(String[] args) {
            FutureTask<String> futureTask = new FutureTask<<u>wait()方法在挂起该线程的同时释放该线程的监视器锁>(new CallerTask());
            new Thread(futureTask).start();
            try{
                String result = futureTask.get();
                System.out.println(result);
            } catch (ExecutionException | InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
```

​		其中实现Runnable接口的方法可以实现方法重用(接口中的方法不占多分空间,而多个Thread子类对象的每一个Run()方法都需要占用堆内存).

<u>**优缺点:**</u>

-   <u>**继承Thread类:方便传参(成员变量,get(),set()方法)**</u>
-   <u>**实现Runnable接口:没有单继承的限制**</u>
-   <u>**FutureTask方法:线程的运行可以有返回值.**</u>

## 3. 线程通知与等待

### (1). wait()函数

​		当一个线程调用了某个对象的wait()方法后,这个线程会被阻塞挂起.

1.  只有当其他线程调用了**<u>此对象</u>**的notify()或notifyAll()方法,该线程才能被返回
1.  当其他线程调用了**<u>该线程</u>**的interrupt()方法,该线程抛出异常返回

​		<u>**要使用某对象wait()函数,就必须实现得到了该对象的监视器锁**</u>(也就是之前的线程锁),有两种途径:1.当前在该对象的**<u>同步方法</u>**(成员方法)中. 2.在该对象的**<u>同步代码块</u>**中.那就意味这,在调用wait()方法时,当前线程一定是被这个对象的监视器锁锁住的,那么**<u>wait()方法在挂起该线程的同时释放该线程的监视器锁</u>**.

​		注意:如果一个线程同时拥有A,B两个对象的监视器锁,调用了对象A的wait()方法后并不会释放B对象的监视器锁.

​		线程被挂起后是有可能无缘无故被唤醒的,这叫做虚假唤醒,通常在唤醒的条件上加while循环(取非)以避免这种情况.

### (2). wait(long timeout)函数

​		多了一个参数,这是一个毫秒(千分之一秒)数,当过了这个时间并且还没有被notify或者notifyAll()方法唤醒,那么该函数还是会因为超时而返回.

### (3). notify()函数

​		随机唤醒一个在该变量的wait()方法上挂起的线程(该对象可能挂了多个线程).和wait()方法一样,都需要会的该对象的监视器锁才能调用.

```mermaid
graph TB
	id0(因为wait方法挂起)
	id1(等待竞争监视器锁,所有因为wait方法被挂起的线程被挂起前一定拥有该对项的监视器锁,在被唤醒后还会因为没有该锁而被挂起)
	id2(继续执行)
	id0--notify方法-->id1
	id1--得到锁-->id2
```

### (4). notifyAll方法

​		会唤醒所有因为该共享变量的wait()方法而被挂起的线程.

## 4. 等待线程执行终止的join方法

​		在主线程中使用,该方法会挂起主线程,当子线程执行完之后返回该方法.

## 5. 让线程睡眠的sleep方法

​		Thread类中有一个静态的Sleep方法,当一个执行中的线程调用了Thread的sleep方法,调用线程会暂停让出CPU的执行权,但**<u>并不让出所拥有的监视器资源</u>**.知道达到指定的睡眠时间后该函数返回,线程处于就绪状态.	

## 6. 让出CPU执行权的yield方法

​		Thread类中有一个静态的yield方法,当一个线程运行这个方法时,实际上就是按时线程调度器让出当前自己的CPU使用权,然后立即处于就绪状态,参与线程轮换.

​		与sleep的不同在于yield方法不会挂起当前线程.

## 7. 线程中断

​		<u>**Java中的线程中断是一种线程间的协作模式,通过修改线程对象中的一个标识(中断标识),在线程运行代码中检测该标识的值,并作出一些动作响应中断.**</u>可以是退出线程也可以是yield,取决于代码实现.

三个方法:

-   void interrupt()方法:中断该线程,将中断标记设置为true.
-   boolean isInterrupted()方法:检测该线程是否被中断
-   boolean interrupted()方法:静态方法,检测**<u>当前调用该方法的线程</u>**是否被中断,如果被中断,修改中断标记为false.

​		另一种用法:当出于一些原因需要立刻唤醒某个线程(因wait()或sleep()方法被挂起)时,可以调用这个线程的interrupt()方法,强制抛出InterruptedException异常,并且返回,线程恢复到激活状态.

## 8. 理解线程上下文切换

​		CPU资源的分配采用时间片轮换的策略,也就是给每一个线程分配一个时间片,线程在时间片内占用CPU执行任务.当前线程使用完时间片后就会处于就绪状态,让出CPU供其他线程使用,这就是上下文切换.

​		上下文切换的时机:当前线程的CPU时间片使用完,处于就绪状态,当前线程被其他线程中断.

## 9. 线程死锁

​		死锁指两个或两个以上的线程在执行过程中,因争夺资源而造成的互相等待的现象.

死锁产生的条件:

-   互斥条件:线程对已经获取到的资源进行排他性使用,即该资源只能由一个线程占用.(监视器锁只能由一个线程获取)
-   请求并持有条件: