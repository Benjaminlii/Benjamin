# 第八章 虚拟机字节码执行引擎

------

[TOC]

------

## 1. 概述

​		所有的Java虚拟机的执行引擎都是一致的:输入的是字节码文件,处理过程是字节码解析的等效过程,输出的是执行结果.

## 2. 运行时帧栈结构

​		栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构,它是虚拟机运行时数据区中的虚拟机栈的栈元素(一个栈帧代表一层方法调用).每一个栈帧都包括了局部变量表,操作数栈,动态链接,方法返回地址和一些额外的附加信息.

​		在编译代码的时候,栈帧中需要多大的局部变量表,多深的操作数栈都是已经完全确定了,并且写入到方法表的Code属性中了的,因此一个栈帧需要分配多大内存不会受到程序运行的影响,仅仅取决于虚拟机的具体实现.

​		一个线程中的方法调用链可能会很长,,对于执行引擎来说,在活动线程中,只有**<u>位于栈顶的栈帧才是有效的,成为当前栈帧,与这个栈帧对应的方法称为当前方法</u>**.

​		典型的栈帧结构如下所示:

![栈帧的概念结构](https://images2015.cnblogs.com/blog/990532/201611/990532-20161113064456420-1511672121.jpg)

### (1). 局部变量表

​		局部变量表是一组变量值存储空间,用于存放方法参数和方法内部定义的局部变量.

​		局部变量表的容量以变量槽(Slot)为最小单位,虚拟机规范中并没有制定一个Slot的大小,只是很有导向性的指明"每个Slot都应该能存放一个boolean,byte,char,short,int,float,reference或者returnAddress类型的数据".二这八种数据类型都可以使用32字节来存放,但这并不代表一个Slot就是32字节,仅仅代表Slot的长度可以随着处理器,操作系统或虚拟机的不同而发生变化.

​		对于64位的数据类型,虚拟机会以高位对齐的方式为其分配两个连续的Slot空间.

​		虚拟机通过索引定位的方式使用局部变量表,索引的范围是从0开始带局部变量表最大的Slot数量.对于64位数据类型的变量,会同时使用n和n+1两个Slot,这种情况下,不允许采用任何方式单独访问其中任意一个Slot,如果遇到了这种字节码指令,Java虚拟机会在校验阶段抛出异常.

​		方法执行时,虚拟机是使用局部变量表完成参数值到参数列表的传递的,如果是实例方法(非static),第0位索引值的Slot默认是用于传递方法所属对象,也就是this对象的引用的.其余参数按照参数表顺序排列,占用从1开始的后续的Slot,参数表分配完后,再根据方法体内部定义的变量的顺序和作用域分配其余的Slot.

​		为了尽可能的节省栈帧空间,局部变量表中的Slot是可以重用的,如果一个变量的作用域已经失效了,这个Slot就会被分配给新的变量使用.

### (2). 操作数栈

​		操作数栈也常常被称为操作栈,它是一个后入先出的栈.与局部变量表一样,操作数栈的最大深度也在编译的时候就已经写入到了Code属性中了.操作数栈的每一个元素可以使任意的Java数据类型,包括64位的long和double(占据的栈容量为2).

​		当一个方法开始执行的时候,操作数栈是空的,方法执行过程中,随着各种指令的直接作用或者需要,往操作数栈中写入和提取内容.例如,如果要进行 `int a = 1 + 1;`,虚拟机会先将1和1压入操作数栈,然后执行相加的命令,这个命令就会从操作数栈中取出两个值进行求和的操作,然后返回结果值.

​		大多数的虚拟机中都会对操作数栈做一些优化处理,另两个帧栈出现一部分重叠,是的两个方法间可以实现变量共享.

### (3). 动态连接

​		每个栈帧都包含一个只想运行时常量池中该帧栈所属方法的引用,这样是为了支持方法调用过程中的动态连接.

​		**<u>Class文件的常量池中有大量的符号引用</u>**,字节码中的方法调用指令就是以常量池中的符号引用作为参数执行方法的.一部分符号引用会在类加载阶段就转化为直接引用,成为静态连接,另一部分**<u>在每一次运行期间转换为直接引用,成为动态连接</u>**.

### (4). 方法返回地址

​		当一个方法开始执行后,只有两种方式可以退出这个方法.第一种是执行引擎遇到了任意一个方法返回的字节码指令,这个时候可能会有返回值返回给上层的方法调用者.这是正常完成出口.

​		另一种退出方式是,在方法执行过程中遇到了异常,而且在方法内没有被处理.这种退出成为异常完成出口,不会给上层调用者任何返回值.

​		无论哪种退出方式,方法退出后,都需要回到上层调用该方法的位置继续执行程序,方法返回时可能需要在栈帧中保存一些信息,用来帮助其恢复上层方法的执行状态.一般来说,调用者的计数器PC的值可以作为返回地址,帧栈中很可能就会保存这个值.

​		方法退出的过程实际上就是栈帧出栈的过程.

### (5). 附加信息

​		虚拟机允许具体的实现增加一些规范里没有的描述信息到栈帧中,实际开发中,一般会把动态连接,方法返回地址与其他附加信息全部归于一类,称为帧栈信息.

## 3. 方法调用

​		方法调用不等同于方法执行,方法调用阶段唯一的任务就是确定被调用方法的版本,也就是确定调用哪一个方法.还没有涉及方法内部的具体运行过程.

### (1). 解析

​		多有方法调用中的目标方法在Class文件中都是一个常量池中的符号引用,在类加载的解析阶段,会将其中一部分符号引用转化为直接引用,这种解析的前提是这个方法在编译器编译时就不许确定下来.主要包含静态方法和私有方法,它们都不可能通过继承或者别的方式重写为其他版本.

### (2). 分派

​		分派调用过程会揭示多态特性的一些最基本实现.

#### 1). 静态分派

先确立一个定义:

```java
Human man = new Man();
```

​		我们把上面的Human称为变量的静态类型,而把Man称为变量的实际类型.静态类型和实际类型在程序中都可以发生一些变化,区别在于静态类型只在使用时发生变化,变量本身不会变化.而实际类型变化的结果只有在程序运行期才能确定下来,编译期并不能知道一个对象的实际类型是什么.

​		编辑器在进行重载时是根据对象的静态类型进行方法的选择的而不是实际类型.

​		所有依赖静态类型来定位方法执行版本的分派动作都称为静态分派.典型的就是重载.

​		静态分派能确定出方法调用的版本,但很多情况下并不唯一,只是确定一个最适合的版本(会找到参数类型转型最少的哪一个重载函数).

#### 2). 动态分派

​		动态分派和重写有很密切的关系.

​		在调用重写的方法时,是根据对象的实际类型来判断执行的方法的.那么虚拟机是如何根据实际类型确定分派方法版本的呢?

​		在调用方法的过程中,会调用invokevirtual指令,这个指令用于调用所有虚方法,即调用除了静态方法,私有方法,父类方法,类构造器方法,接口方法和动态执行之外的所有方法.这个指令会找到操作数栈定的第一个元素所指向的对象的实际类型,然后按照继承关系从子类到父类一个一个的查找是否有满足要求的方法.这就意味着,普通方法的执行是根据对象的实际类型来寻找分派方法的.

#### 3). 单分派和多分派

​		方法的接收者和方法的参数统称为方法的宗量,根据分配基于多少种宗量,可以讲分派划分为单分派和多分派,

​		单分派是根据一个宗量对目标方法进行选择,多分派则根据多个宗量.

​		Java是静态多分派,动态单分派的语言(重载方法只根据调用者的实际类型选择分派方法,所以是单分派的).

#### 4). 虚拟机动态分派的实现

​		动态分派是非常频繁的动作,每一次动态分派都在类的方法元数据中搜索合数的目标方法,因此在虚拟机的实际实现中大部分都会加以优化.最常用的手段就是为类在方法区建立一个虚方法表,记录类内部各种方法和方法的信息,使用虚方法表索引来代替元数据查找以提高性能.

​		虚方法表中存放着各个方法的入口,如果某个方法在子类中没有被重写,那么子类的虚方法表中方法的地址入口和父类相同方法中的地址入口是一致的.

### (3). 动态类型语言支持

#### 1). 动态类型语言

​		动态类型语言的关键特征是它的类型检查的主题是在运行期而不是编译期.(Java是静态类型语言,在编译器就进行了类型检查)

#### 2). JDK 1.7与动态类型

​		Java虚拟机虽然支持许多的动态类型语言,但是支持一直存在着欠缺.

#### 3). java.lang.invoke包

​		这个包提供了一种新的动态确定目标方法的机制,称为MethodHandle.也就是反射技术中调用方法的方法.