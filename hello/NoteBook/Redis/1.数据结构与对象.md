# 第一部分 数据结构与对象

-----

[toc]

-----

## 1. 简单动态字符串

​		Redis自己构建了一种名为简单动态字符串(SDS)的抽象类型,并将其作为Redis的默认字符串表示.在Redis中,包含字符串值的键值对在底层都是SDS实现的.C字符串只会作为字面量使用.

### (1). SDS的定义

```c
struct sdshdr{
	// 记录出发数组中已经使用了的字符数量
    // 也就是sds所保存的字符串的长度
    int len;
	
    // 记录空闲空间的数量
	int free;
	
    // 字节数组,存储字符数据
	char buf[];
}
```

​		SDS遵循C字符串以空字符('\0')结尾的惯例,目的是为了直接重用一部分C字符串库函数.但是这个空字符是不计入len属性中的.

### (2). SDS和C字符串的区别

​		C字符串并不能满足Redis在安全性,效率以及功能方面的要求.

#### 1). 获取字符串长度

​		SDS可以常数复杂度的获取字符串的长度,因为数据结构中已经存储了字符串的长度,不需要遍历数组去求累计和.

#### 2). 杜绝缓冲区溢出

​		在修改前会判断空间是否足够使用(free字段的值),而如果使用C字符串,需要先进行手动判断,保证空间足够.

​		SDS API对SDS进行修改时,API会检查SDS的空间是否满足修改所需的要求.如果不足,则会自动进行扩容.

#### 3). 减少修改字符串时带来的内存充分配次数

​		C字符串的底层总是空间大小刚好合适(n+1).这样对字符串进行修改时,就经常会涉及到内存的重分配.SDS中保留了空闲空间,接触了字符串长度和底层数组长度的关联.

​		通过未使用空间,SDS实现了==**空间预分配**==和==**惰性空间释放**==两种优化策略.

##### 1>. 空间预分配

​		每次都额外分配内存,减少内存重新分配.优化SDS的增长.

​		额外分配的内存等于所使用的内存,但不超过1 MB.

​		拓展SDS时会优先使用空闲空间,如果空闲空间不足,才会重新分配内存.

##### 2>. 惰性空间释放

​		长度缩短时,不会立刻回收内存.优化SDS缩短.

​		SDS提供了相应API,可以手动的真正释放SDS未使用的空间.从而不会造成内存浪费.

#### 4). 二进制安全

​		不需要考虑'/0'的意义,那么就可以存储二进制数据.

#### 5). 兼容部分C字符串函数



## 2. 链表

>   Redis使用的C语言没有内置链表的实现,所以Redis构建了自己的实现方式.
>
>   当list内存储了较多的元素或者list中包含的元素都是较长的字符串时,Redis就会使用链表作为列表的底层实现.

链表的数据结构实现略过.

### (1). 链表和链表节点的实现

```c
// 链表节点的定义
typedef struct listNode{
    // 前继节点
    struct listNode *prev;
    // 后继节点
    struct listNode *prev;
    // 指向节点存储的数据
    void *value;
}listNode;

// 链表的数据结构定义
typedef struct list{
    // 头结点
    listNode *head;
    // 尾节点
    listNode *tail;
    // 链表长度
    unsigned long len;
    // 复制链表节点的函数
    void *(*dup)(void *ptr);
    // 释放链表节点的函数
    void (*free)(void *ptr);
    // 节点值对比函数
    int (*match)(void *ptr, void *key);
}list;
```

>   void * 的用法相当于Java中的Object,可以保存所有类型的指针.

​		list中存储了链表的长度,所以可以O(1)时间复杂度获取数据量.

## 3. 字典

>   字典在Redis中的应用非常广泛,Redis中的数据库就是使用字典作为底层实现的(从数据结构的key得到数据结构的对象).
>
>   字典还是哈希类型的底层实现之一,当一个哈希类型包含的键值对比较多,或者键值对中的元素都是比较成的字符串时,Redis就会使用字典作为哈希类型的底层实现.

### (1). 字典的实现

#### 1). 哈希表以及其节点的定义

​		Redis字典所使用的哈希表的定义:

```c
// 哈希表节点的定义
typedef struct dictEntry{
    // 键
    void *key;
    // 值(枚举类型,分别存储结构体类型,无符号数和有符号数)
    union{
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;
    // 指向下一个节点
    struct dictEntry *next;
}dictEntry;

// 哈希表整体数据结构的定义
typedef struct dictht{
    // 节点数组(第一个星号表示数组,第二个表示数组中存储的是指向字节节点的指针)
    dictEntry **table;
    // 哈希表的大小
    unsigned long size;
    // 哈希表大小减一,用于方便计算索引值(散列)
    unsigned long sizemask;
    // 已占用的空间数
    unsigned long used;
}
```

​		从以上定义可以看出,Redis中哈希表的底层和Java中HashMap的底层数据结构定义是一样的,嗾使使用数组+链表存储数据,使用链地址法(拉链法)解决哈希冲突.

#### 2). 字典

​		Redis中的字典的数据结构定义:

```c
// 这个结构体中定义了一些操纵特定类型键值对的函数,Redis会为不同用途的字典设置不用的函数
// 是为了创建多态字典使用的
typedef struct dictType{
    // 计算哈希值的函数
    unsigned int (*hashFunction)(const void *key);
    // 复制键
    void *(*keyDup)(void *privdata, const void *key);
    // 复制值
    void *(*valDup)(void *privdata, const void *obj);
    // 对比键
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);
    // 销毁键
    void (*keyDestructor)(void *privadata, void *key);
    // 销毁值
    void (*valDestructor)(void *privadata, void *obj);
}
// 这个是字典的结构体定义
typedef struct dict{
    // 这个字典使用的方法
    dictType *type;
    // 私有数据
    void *privdata;
    // 每一个字典都会使用两个哈希表,ht[1]的哈希表只会在ht[0]的哈希表rehash时才会使用
    dictht ht[2];
    // rehash索引,当rehash不再进行时,为-1(相当于状态量,根据这个状态量判断从ht[0]或者ht[1]中取出数据)
    int rehashidx;
}
```

### (2). 哈希算法

​		当要插入键值对时,先要根据插入的键计算出哈希值,然后根据这个哈希值散列到哈希表节点的数组中.

```c
// 每一个字典使用的哈希方法可能是不一样的
hash = dict->type->hashFunction(key);
// 得到哈希值之后,对哈希值和数组长度减一按位与得到数组中的下标
index = hash & dict->ht[x].sizemask;
```

### (3). 解决键冲突

​		Redis中的哈希表使用链地址法解决哈希冲突.

​		因为dictEntry中的链表是单向链表,所以新节点会使用头插法进入链表.

### (4). rehash

Redis中哈希表的rehash机制:

​		二倍对ht[1]扩容(这里保证了容量为2^n,在hash的时候使用了按位与)

​		rehash时全部重新hash到另外一张表中

​		释放原表,然后将新表设置为ht[0],并在ht[1]处创建空白表(这里的空白是指没有初始化数组,但是有其他部分数据)

>   哈希表的扩容和收缩:
>
>   当满足以下条件时,程序自动进行哈希表的扩容:
>
>   1.  服务器没有在执行BGSAVE或者BGREWRITEAOF命令(后台线程持久化数据),并且哈希表的负载因子大于1(负载因子: 元素数 / 桶数量)
>   1.  服务器正在进行后台线程持久化数据,并且负载因子大于5
>
>   另一方面,当负载因子小于0.1时,程序自动进行哈希表的收缩操作.caozuo

### (5). 渐进式rehash

​		rehash动作并不是一次性执行完的,而是分多次,渐进式地完成的.(防止Redis短时间内被rehash占用cpu而停止服务)

​		这个过程是从哈希数组的0号位置向后进行的,rehashidx(rehash索引)表示当前进行到的位置,当rehashidx累加到数组长度时,渐进式rehash结束,设置为-1.

>   渐进式rehash期间对哈希表的操作:
>
>   ​		在渐进式rehash进行时,字典会同时使用两个哈希表,例如:如果要找一个键,会现在ht[0]上面寻找,如果没能找到,再在ht[1]上寻找.
>
>   ​		所有的新值一律会保存到ht[1]中,也就是新表中,保证ht[0]中的数据只减不增.,并且锁着rehash的进行被全部复制到新表中,最后被清空.

## 4. 跳跃表

>   跳跃表是一种数据结构,通过在每个节点中维持多个指向其他节点的指针从而达到快速访问节点的目的.
>
>   Redis采用跳跃表作为有序集和(zset)的底层实现之一,当zset包含的元素数量较多又或者zset中存储的都是较长的字符串时,Redis就会使用跳跃表作为zset的底层实现.
>
>   同链表,字典等数据结构被广泛的应用在Redis中不同,Redis内部只在zset和集群节点中使用到了跳跃表.

[跳表──没听过但很犀利的数据结构](https://lotabout.me/2018/skip-list/)

### (1). 跳跃表的定义

​		跳跃表是链表的进化版解决了链表查找元素时间复杂度常量阶的缺点.常常用来代替平衡树(实现更简单,效率也不低).

​		跳表相当于在链表的节点中存储了多个next指针,根据跳跃的维度不同加以区分,在内存表示中将步长(这里的步长并不是确定的,只能大致认为上层的步长比下层的要大)越大的指针放在上面,步长小的放在下面,如此就有了层的概念,如图所示:

![跳表的空间图示](/home/benjamin/.config/Typora/typora-user-images/image-20200222174936878.png)

​		查找时,先根据高层级指针向后寻找,如果找到的元素大于要寻找的元素,向回退一步,使用低一层的指针向后访问.当步长为1并且还没有找到时,就意味着整个表中都没有这个元素.

### (2). 跳跃表节点

​		跳跃表节点的数据结构定义:

```c
typedef struct zskiplistNode {
    // 后退指针
    // 用于从后向前遍历元素(从前向后只需要挨个访问层级为0的前进指针即可)
    struct zskiplistNode *backward;
    // 该节点的分值,跳跃表中元素排列的依据,可以理解为跳跃表也是一个按照分值有序的链表
    // 当分值相等时,将存储对象的大小作为排序的依据
    // 这应该是Redis中跳表实现独有的
    double score;
    // 节点内存储的对象
    robj *obj;
    // 节点处于各个层的层对象
    struct zskiplistLevel {
        // 前进指针
        struct zskiplistNode *forward;
        // 本次前进的跨度
        unsigned int span;
    } level[];
} zskiplistNode;
```

#### 1). 层

​		每一个节点的层数是使用数组存储的,就可以做到扩容.

​		每创建一个新链表节点时,程序都根据幂次定律(越大的数,生成的概论越小)生成一个1~32的值作为level数组的大小,这个大小就是这个节点最大的层的高度,也就是可以为访问到的最高的层.

#### 2). 前进指针

​		这个指针是每一个有独立的,向后访问时,先使用高层级的前进指针访问,如果没找到,再使用低一级的前进指针访问.直到层级为0.

#### 3). 跨度

​		跨度表示这个前进指针前进的步数,用于在访问节点时计算节点在跳跃表中的排位.

​		指向null的前进指针对应的跨度为0,表示不连接任何节点.

### (3). 跳跃表

​		数据结构定义如下:

```c
typedef struct zskiplist {
    // 头节点，尾节点
    struct zskiplistNode *header, *tail;
    // 节点数量
    unsigned long length;
    // 目前表内节点的最大层数
    int level;
} zskiplist;
```

​		表头结点是不存储数据的,并且表内节点的最大层数也不考虑表头结点.

​		最大层数用于选择一开始使用那一层的前进指针进行遍历.

## 5. 整数集合

>   整数集合是集合(set)的底层实现之一,当一个集合中只包含整型元素时,并且数量不多,Redis就会使用整数集合作为集合的底层实现.

### (1). 整数集合的实现

​		整数集合是Redis用于保存整数值的集合抽象数据结构,可以保存int16_t,int32_t或者int64_t.

​		结构体定义如下:

```c
typedef struct intset{
    // 编码方式
    uint32_t encoding;
    // 集合包含的元素数量
    uint32_t length;
    // 保存元素的数组(这里的类型为最基本的类型,后面根据不同的encoding,使用多个格子表示一个元素)
    int8_t contents[];
} intset;
```

-   encoding:决定了contents数组中值的类型
-   length:记录整个整数集合包含的元素数量
-   contents:虽然定义为int8_t,但是实际的类型还是决定于encoding.并且数组中的元素在数组中按照大小升序排列.不包含重复项

​		对整数集合的各种操作类似ArrayList.

​		对元素的查找是二分的,插入操作也会先找这个元素,也是先二分,在移动后面的元素.

### (2). 升级

​		当要添加一个元素,但是这个元素超出了现有的编码方式的取值范围时,就需要执行升级来对数组的元素进行扩充.然后才可以将这个元素插入到整数集合中.

​		大致步骤如下:

1.  根据新元素的类型,扩展整数集合底层数组的空间大小,并且分配新元素的空间(在原有空间基础上进行扩容,而不是重新分配整个新的数组)
1.  将原先就存在的数据转换为新的类型,并且放置到正确的位置上,要保证有序性(对旧元素来说,是从后向前遍历的).在空间的使用上面,起始位置变为原来的二倍,结束位置变为二倍加一
1.  将新元素添加到底层数组中

>   因为能引起升级的元素是超出原有的元素取值范围的,所以要么比所有元素大,要么比所有元素小,所以最后这个元素会被放在索引处为0或者length-1的位置上.

升级操作是单向的,不存在降级的行为.

### (3). 升级的好处

1.  提升灵活性:避免类型错误
1.  节约内存:为了实现上面的做法,也可以直接使用int64_t作为底层实现,不过太过耗费内存.

## 6. 压缩链表

>   压缩链表是list和hash的底层实现之一.
>
>   当一个list中只包含少量元素并且每一个元素都是小的整数值或者长度较短的字符串时,Redis就会使用压缩链表作为list的底层实现.
>
>   当一个hash中只包含少量的键值对并且每个键值对都是小整数值或者长度较短的字符串时,Redis就会使用压缩表来作为hash的底层实现.

### (1). 压缩列表的构成

​		压缩列表是Redis为了节约内存而开发的,是由一些列特殊编码的连续内存块组成的顺序型数据结构.一个压缩列表可以包含任意多个节点,一个节点可以存储一个字节数组或者一个整数值.

​		压缩列表的组成:

| 属性    | 类型     | 长度  | 用途                                                         |
| ------- | -------- | ----- | ------------------------------------------------------------ |
| zlbytes | uint32_t | 4字节 | 记录整个压缩列表的内存大小,内存重分配和计算zllen时使用       |
| zltail  | uint32_t | 4字节 | 记录压缩列表的尾节点距整个压缩列表的起始地址有多少字节,用于确定尾节点(尾节点的大小不定) |
| zllen   | uint16_t | 2字节 | 记录压缩列表的节点个数,因为无符号2字节只能存储0~65535,如果压缩列表的长度大于这个值,需要全表遍历才能得到表的长度 |
| entryX  | 列表节点 | 不定  | 埃索列表的各个节点,节点的大小由每一个节点所保存内容决定      |
| alend   | uint8_t  | 1字节 | 特殊值:0xFF(255),用于标记压缩列表的结束                      |

### (2). 压缩列表节点的构成

​		每一个压缩列表节点可以保存一个字节数组(0-2^6^-1, 0-2^14^-1, 0-2^32^-1)或者一个整数值(4位无符号,1字节有符号,3字节有符号,int16_t类型,int32_t类型,int64_t类型),每一个节点的构成如下:

#### 1). previous_entry_length

​		前一个节点的长度(以字节为单位).

​		如果前一个节点大小小于254字节,那么这个属性只占一个字节,如果超出254,那么这个属性占5字节.

​		记录这个值的目的在于可以直接计算得出前一个节点的起始地址.压缩列表从表尾向表头遍历就是通过这个原理实现的.只要拥有了一个指向某节点其实地址的指针,就可以一直向前寻找,知道到达头节点.

#### 2). encoding

​		这个属性记录了节点的content属性锁保存的数据的类型以及长度