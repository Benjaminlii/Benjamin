# 第三部分 多机数据库的实现

-----

[toc]

-----

## 1. 复制

​		在Redis中,用户可以通过执行SLAVEOF命令或者设置slaveof选项,让一个服务器去复制另一个服务器,我们把被复制的服务器成为主服务器,对主服务器进行复制的服务器成为从服务器.也就是我们常说的主从复制.

​		命令使用方式如下:

```
redis> SLAVEOF xxx.xxx.xxx.xxx 6379
```

​		进行复制的主从服务器双方将==保存相同的数据==,概念上称为==服务器状态一致==.

### (1). 旧版复制功能的实现(Redis 2.8之前)

​		Redis的复制功能分为同步(将从服务器的状态更新至主服务器)和命令传播(主服务器被更改后,让主从服务器重新一致)两个操作.

#### 1). 同步

​		当客户端向发送了SLAVEOF命令,==进入主从复制模式==的时候,从服务器首先要进行同步操作,也就是==将从服务器中的数据更新为主服务器的数据库状态==.

​		通过SYNC命令完成,执行步骤如下:

1.  从服务器向主服务器发送SYNC命令
1.  主服务器收到后执行BGSAVE命令,生成一个RDB文件后使用一个缓冲区记录从现在开始执行的所有写命令
1.  主服务器的BGSAVE执行完之后,主服务器将RDB文件发给从服务器,从服务器进行加载,这时从服务器就会更新成主服务器执行BGSAVE命令前的数据库状态
1.  主服务器将命令缓冲中的命令全部发送给从服务器,从服务器执行完之后达到主从一致的效果

#### 2). 命令传播

​		当主服务器执行写命令的时候,主服务器的数据库状态就可能被改变,导致打破主从一致.

​		为了保持主从一致,主服务器需要将自己执行的写命令发送给从服务器执行,从服务器执行后,从新回到主从一致状态.

### (2). 旧版功能的缺陷

​		对于从服务器从来没有复制过任何服务器的初次复制情况,这种方案能够完成任务.但是如果是从服务器由于网络原因断线后的重新复制来说,效率就很低了.

​		因为这时还是会使用RDB文件作为同步的媒介,很大一部分数据是重复的.

### (3). 新版复制功能的实现

​		Redis从2.8版本开始使用PSYNC命令代替SYNC命令来执行复制时的同步操作.

​		PSYNC具有完成重同步和部分重同步两种模式:

1.  完整重同步用于初次复制,和SYNC命令基本一样
1.  部分重同步用于断线后的重复制,如果条件允许,主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器

### (4). 部分重同步的实现

​		部分重同步功能由一下三部分构成:

1.  主服务器的肤质偏移量和从服务器的复制偏移量
1.  从服务器的复制积压缓存
1.  服务器的运行ID

#### 1). 复制偏移量

​		主服务器和从服务器都会维护一个复制偏移量.

-   主服务器每次向从服务器传播N个字节数据时,九江自己的复制偏移量加上N
-   从服务器每次收到数据也会更新复制偏移量

​		通过==对比==主从服务器的==复制偏移量==就可以知道主从服务器是否处于主从一致状态

#### 2). 复制积压缓冲区

​		复制积压缓冲区是主服务器维护的一个==固定长度先进先出队列==,默认大小1MB.内部存储了一系列命令的字节数组表示和其中每一个字节对应的复制偏移量(也就是说,是可以清楚的知道每一条命令的复制偏移量).

​		主服务器进行==命令传播==时,不仅仅会将命令==发给从服务器==,还==写入复制积压缓冲区中==.因此复制积压缓冲区中会保存最新的1MB命令数据.当从服务器重新连上主服务器时,从服务器根据自己的复制偏移量决定接下来的操作:

1.  如果从服务器的复制偏移量不在复制积压缓冲区中,那么进行完整重同步操作
1.  否则,说明从服务器中缺失的命令在复制积压缓冲区中都存在,根据复制偏移量选择起始位置进行部分重同步操作

#### 3). 服务器运行ID

​		每一个Redis服务器,不论主从都有自己的运行ID,这个ID由服务器启动时自动生成,是一个40位十六进制数.在进行主从复制时,从服务器会保存主服务器的运行ID.

​		在进行断线重连之后,从服务器会将之前自己保存的主服务器的运行ID发送给新的主服务器,如果一致,那么说明这是一次重连,进行部分重同步操作.不一致则说明两次连接的不是一个服务器,要进行完整重同步操作.

### (5). PSYNV命令的实现

​		PSYNC命令的调用方法有两种:

1.  如果从服务器从来没有连接过主服务器,或者已经主动断开了,那么在开始第一次新的复制时,主动请求服务器进行完整重同步.
1.  如果从服务器已经父之过某个服务器,那么将之前复制的主服务器的运行ID和自己的复制偏移量发送给主服务器,由主服务器决定进行哪一种同步操作;

​		主服务器的回应会是下面三种之一:

1.  如果主服务器要与从服务器进行完整重同步,那么会把主服务器的运行ID发送给从服务器保存,将主服务器的复制偏移量发送给从服务器作为复制偏移量的起始值
1.  如果主服务器要与从服务器进行部分重同步,那么从服务器只需要等到主服务器将自己缺少的数据发送过来即可
1.  如果主服务器的版本低于2.8,识别不了PSYNC命令,那么会让从服务器重新发送一个SYNC命令进行完整的重同步

### (6). 复制的实现

​		通过向服务器(这里是从服务器)发送SLAVEOF命令也可以让服务器去和其他服务器进行主从连接.

#### 1). 步骤1:设置主服务器的地址和端口

​		当客户端向服务器发送SLAVEOF命令请求时,从服务器首先要做的就是将发送来给定的主服务器IP和端口保存在服务器状态中:

```c
struct redisServer{
    // .....
    
    // 主服务器的地址
    char *masterhost;
    // 主服务器端口
    int masterport;
    
    // .....
}
```

​		然后服务器会向客户端回复OK,随后才开始真正执行命令的内容.

#### 2). 步骤2:建立连接套接字

​		从服务器根据命令设置的IP和端口,创建连向主服务器的套接字连接,如果成功创建,那么从服务器将为这个套接字关联一个专门处理复制工作的事件处理器,复制工作的所有内容在后面都是由这个套接字完成的,

​		主服务器在接受这个套接字连接后,会创建响应的客户端状态,并将从服务器当做链接到主服务器的一个客户端来看待.

#### 3). 步骤3:发送PING命令

​		从服务器成为主服务器的客户端后,第一件事就是发送PING命令,PING命令有两个作用:

1.  检查套接字的读写状态是否正常
1.  检查主服务器能否正常处理命令请求

​		从服务器会收到三种响应之一:

1.  主服务器发送了一个命令回复,但是从服务器并没有在有限时间内读取出回复的内容,那么说明当前的网络连接状态不佳.会进行断开重连
1.  主服务器向从服务器返回一个错误,表示主服务器暂时没办法处理从服务器的命令请求.从服务器会进行断开重连
1.  从服务器收到PONG回复,那么说明状况良好,可以进行下面的操作

#### 4). 步骤4:身份验证

​		从服务器收到PONG回复后,如果设置了masterauth,那么进行身份验证.

​		从服务器将向主服务器发送一条AUTH命令,参数为从服务器masterauth选项的值.

​		从服务器可能遇到的情况:

1.  主服务器没有设置requirepass选项,并且从服务器没有设置masterauth,那么跳过这个阶段
1.  如果从服务器通过AUTH命令发送的密码和主服务器requirepass选项设置的相同,那么验证成功,继续进行
1.  如果主从服务器只有一个进行了设置,那么返回一个错误

#### 5). 步骤5:发送端口信息

​		从服务器向主服务器发送从服务器监听的端口号.主服务器收到后,会记录在从服务器的客户端状态中.

#### 6). 步骤6:同步

​		从服务器向主服务器发送PSYNC命令,执行同步操作.

​		值得一提的是,在执行同步操作过后,主服务器也将成为从服务器的客户端(双方可以相互发送请求和回复),因为无论怎样,主服务器都需要向从服务器发送命令请求来同步数据.

#### 7). 步骤7:命令传播

​		主从服务器进入命令传播阶段,主服务器一直想自己执行的写命令发送给从服务器,从服务器一直接收并执行就可以保持主从一致.

### (7). 心跳检测

​		从服务器会以每秒一次的频率向服务器发送命令:

```
// 参数是从服务器的复制偏移量
REPLCONF ACK <replication_offset>
```

​		有三个作用:

1.  检测主从服务器的网络连接状态
1.  辅助实现min-slaves选项
1.  检测命令丢失

#### 1). 检测网络连接状态

​		如果至服务器超过一秒没有接收到REPLCONF ACK命令,那么主服务器就知道网络连接出现问题了.

​		这个计时的值被称为lag,应该在0\~1浮动.

#### 2). 辅助实现min-slaves配置选项

​		这个选项可以防止主服务器在不安全的情况下执行写命令.

​		可以配置从服务器少于多少,lag值大于多少的情况下,主服务器不执行写命令.

#### 3). 检测命令丢失

​		主服务器接收到REPLCONF ACK命令,取出其中的从服务器复制偏移量,与自己的复制偏移量进行对比,如果不一致,那么从复制积压缓冲区中找到服务器缺少的数据,重新发送给从服务器.

​		这部分和部分重同步操作的原理很像.

​		Redis 2.8版本之前没有检测丢失的功能.