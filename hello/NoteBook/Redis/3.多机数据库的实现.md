# 第三部分 多机数据库的实现

-----

[toc]

-----

## 1. 复制

​		在Redis中,用户可以通过执行SLAVEOF命令或者设置slaveof选项,让一个服务器去复制另一个服务器,我们把被复制的服务器成为主服务器,对主服务器进行复制的服务器成为从服务器.也就是我们常说的主从复制.

​		命令使用方式如下:

```
redis> SLAVEOF xxx.xxx.xxx.xxx 6379
```

​		进行复制的主从服务器双方将==保存相同的数据==,概念上称为==服务器状态一致==.

### (1). 旧版复制功能的实现(Redis 2.8之前)

​		Redis的复制功能分为同步(将从服务器的状态更新至主服务器)和命令传播(主服务器被更改后,让主从服务器重新一致)两个操作.

#### 1). 同步

​		当客户端向发送了SLAVEOF命令,==进入主从复制模式==的时候,从服务器首先要进行同步操作,也就是==将从服务器中的数据更新为主服务器的数据库状态==.

​		通过SYNC命令完成,执行步骤如下:

1.  从服务器向主服务器发送SYNC命令
1.  主服务器收到后执行BGSAVE命令,生成一个RDB文件后使用一个缓冲区记录从现在开始执行的所有写命令
1.  主服务器的BGSAVE执行完之后,主服务器将RDB文件发给从服务器,从服务器进行加载,这时从服务器就会更新成主服务器执行BGSAVE命令前的数据库状态
1.  主服务器将命令缓冲中的命令全部发送给从服务器,从服务器执行完之后达到主从一致的效果

#### 2). 命令传播

​		当主服务器执行写命令的时候,主服务器的数据库状态就可能被改变,导致打破主从一致.

​		为了保持主从一致,主服务器需要将自己执行的写命令发送给从服务器执行,从服务器执行后,从新回到主从一致状态.

### (2). 旧版功能的缺陷

​		对于从服务器从来没有复制过任何服务器的初次复制情况,这种方案能够完成任务.但是如果是从服务器由于网络原因断线后的重新复制来说,效率就很低了.

​		因为这时还是会使用RDB文件作为同步的媒介,很大一部分数据是重复的.

### (3). 新版复制功能的实现

​		Redis从2.8版本开始使用PSYNC命令代替SYNC命令来执行复制时的同步操作.

​		PSYNC具有完成重同步和部分重同步两种模式:

1.  完整重同步用于初次复制,和SYNC命令基本一样
1.  部分重同步用于断线后的重复制,如果条件允许,主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器

### (4). 部分重同步的实现

​		部分重同步功能由一下三部分构成:

1.  主服务器的肤质偏移量和从服务器的复制偏移量
1.  从服务器的复制积压缓存
1.  服务器的运行ID

#### 1). 复制偏移量

​		主服务器和从服务器都会维护一个复制偏移量.

-   主服务器每次向从服务器传播N个字节数据时,九江自己的复制偏移量加上N
-   从服务器每次收到数据也会更新复制偏移量

​		通过==对比==主从服务器的==复制偏移量==就可以知道主从服务器是否处于主从一致状态

#### 2). 复制积压缓冲区

​		复制积压缓冲区是主服务器维护的一个==固定长度先进先出队列==,默认大小1MB.内部存储了一系列命令的字节数组表示和其中每一个字节对应的复制偏移量(也就是说,是可以清楚的知道每一条命令的复制偏移量).

​		主服务器进行==命令传播==时,不仅仅会将命令==发给从服务器==,还==写入复制积压缓冲区中==.因此复制积压缓冲区中会保存最新的1MB命令数据.当从服务器重新连上主服务器时,从服务器根据自己的复制偏移量决定接下来的操作:

1.  如果从服务器的复制偏移量不在复制积压缓冲区中,那么进行完整重同步操作
1.  否则,说明从服务器中缺失的命令在复制积压缓冲区中都存在,根据复制偏移量选择起始位置进行部分重同步操作

#### 3). 服务器运行ID

​		每一个Redis服务器,不论主从都有自己的运行ID,这个ID由服务器启动时自动生成,是一个40位十六进制数.在进行主从复制时,从服务器会保存主服务器的运行ID.

​		在进行断线重连之后,从服务器会将之前自己保存的主服务器的运行ID发送给新的主服务器,如果一致,那么说明这是一次重连,进行部分重同步操作.不一致则说明两次连接的不是一个服务器,要进行完整重同步操作.

### (5). PSYNV命令的实现

​		PSYNC命令的调用方法有两种:

1.  如果从服务器从来没有连接过主服务器,或者已经主动断开了,那么在开始第一次新的复制时,主动请求服务器进行完整重同步.
1.  如果从服务器已经父之过某个服务器,那么将之前复制的主服务器的运行ID和自己的复制偏移量发送给主服务器,由主服务器决定进行哪一种同步操作;

​		主服务器的回应会是下面三种之一:

1.  如果主服务器要与从服务器进行完整重同步,那么会把主服务器的运行ID发送给从服务器保存,将主服务器的复制偏移量发送给从服务器作为复制偏移量的起始值
1.  如果主服务器要与从服务器进行部分重同步,那么从服务器只需要等到主服务器将自己缺少的数据发送过来即可
1.  如果主服务器的版本低于2.8,识别不了PSYNC命令,那么会让从服务器重新发送一个SYNC命令进行完整的重同步

### (6). 复制的实现

​		通过向服务器(这里是从服务器)发送SLAVEOF命令也可以让服务器去和其他服务器进行主从连接.

#### 1). 步骤1:设置主服务器的地址和端口

​		当客户端向服务器发送SLAVEOF命令请求时,从服务器首先要做的就是将发送来给定的主服务器IP和端口保存在服务器状态中:

```c
struct redisServer{
    // .....
    
    // 主服务器的地址
    char *masterhost;
    // 主服务器端口
    int masterport;
    
    // .....
}
```

​		然后服务器会向客户端回复OK,随后才开始真正执行命令的内容.

#### 2). 步骤2:建立连接套接字

​		从服务器根据命令设置的IP和端口,创建连向主服务器的套接字连接,如果成功创建,那么从服务器将为这个套接字关联一个专门处理复制工作的事件处理器,复制工作的所有内容在后面都是由这个套接字完成的,

​		主服务器在接受这个套接字连接后,会创建响应的客户端状态,并将从服务器当做链接到主服务器的一个客户端来看待.

#### 3). 步骤3:发送PING命令

​		从服务器成为主服务器的客户端后,第一件事就是发送PING命令,PING命令有两个作用:

1.  检查套接字的读写状态是否正常
1.  检查主服务器能否正常处理命令请求

​		从服务器会收到三种响应之一:

1.  主服务器发送了一个命令回复,但是从服务器并没有在有限时间内读取出回复的内容,那么说明当前的网络连接状态不佳.会进行断开重连
1.  主服务器向从服务器返回一个错误,表示主服务器暂时没办法处理从服务器的命令请求.从服务器会进行断开重连
1.  从服务器收到PONG回复,那么说明状况良好,可以进行下面的操作

#### 4). 步骤4:身份验证

​		从服务器收到PONG回复后,如果设置了masterauth,那么进行身份验证.

​		从服务器将向主服务器发送一条AUTH命令,参数为从服务器masterauth选项的值.

​		从服务器可能遇到的情况:

1.  主服务器没有设置requirepass选项,并且从服务器没有设置masterauth,那么跳过这个阶段
1.  如果从服务器通过AUTH命令发送的密码和主服务器requirepass选项设置的相同,那么验证成功,继续进行
1.  如果主从服务器只有一个进行了设置,那么返回一个错误

#### 5). 步骤5:发送端口信息

​		从服务器向主服务器发送从服务器监听的端口号.主服务器收到后,会记录在从服务器的客户端状态中.

#### 6). 步骤6:同步

​		从服务器向主服务器发送PSYNC命令,执行同步操作.

​		值得一提的是,在执行同步操作过后,主服务器也将成为从服务器的客户端(双方可以相互发送请求和回复),因为无论怎样,主服务器都需要向从服务器发送命令请求来同步数据.

#### 7). 步骤7:命令传播

​		主从服务器进入命令传播阶段,主服务器一直想自己执行的写命令发送给从服务器,从服务器一直接收并执行就可以保持主从一致.

### (7). 心跳检测

​		从服务器会以每秒一次的频率向服务器发送命令:

```
// 参数是从服务器的复制偏移量
REPLCONF ACK <replication_offset>
```

​		有三个作用:

1.  检测主从服务器的网络连接状态
1.  辅助实现min-slaves选项
1.  检测命令丢失

#### 1). 检测网络连接状态

​		如果至服务器超过一秒没有接收到REPLCONF ACK命令,那么主服务器就知道网络连接出现问题了.

​		这个计时的值被称为lag,应该在0\~1浮动.

#### 2). 辅助实现min-slaves配置选项

​		这个选项可以防止主服务器在不安全的情况下执行写命令.

​		可以配置从服务器少于多少,lag值大于多少的情况下,主服务器不执行写命令.

#### 3). 检测命令丢失

​		主服务器接收到REPLCONF ACK命令,取出其中的从服务器复制偏移量,与自己的复制偏移量进行对比,如果不一致,那么从复制积压缓冲区中找到服务器缺少的数据,重新发送给从服务器.

​		这部分和部分重同步操作的原理很像.

​		Redis 2.8版本之前没有检测丢失的功能.

## 2. Sentinel

​		Sentinel(哨兵)是Redis的高可用性解决方案:==有一个过着多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器以及每一台主服务器下的所有从服务器,当被监视的一台主服务器下线时,自动将这台主服务器下的某个从服务器升级为新的主服务器,然后继续维持主从一致==.

![image-20200305155337016](/home/benjamin/.config/Typora/typora-user-images/image-20200305155337016.png)

稳定状态1:

![image-20200305155346617](/home/benjamin/.config/Typora/typora-user-images/image-20200305155346617.png)

主服务器下线:

![image-20200305155359622](/home/benjamin/.config/Typora/typora-user-images/image-20200305155359622.png)

哨兵进行调整:

![image-20200305155412649](/home/benjamin/.config/Typora/typora-user-images/image-20200305155412649.png)

1.  Sentinel会挑选原主服务器下的其中一个从服务器,将这个从服务器升级为主服务器
1.  Sentinel系统向原主服务器下的其他所有从服务器发送新的复制指令,建立新的主从复制
1.  Sentinel继续监视那个下线的服务器,当这个服务器重新上线时,成为一个从服务器

### (1). 启动并初始化Sentinel

​		启动Sentinel可以使用命令:

```
redis-sentinel /path/to/your/sentinel.conf
或者
redis-server /path/to/your/sentinel.conf --sentinel
```

​		一个Sentinel启动时,会执行以下步骤:

1.  初始化服务器
1.  将普通的Redis服务器使用的代码转换成Sentinel专用代码
1.  初始化Sentinel状态
1.  根据指定的配置文件,初始化Sentinel监视的主服务器列表
1.  创建连向主服务器的网络连接

#### 1). 初始化服务器

​		Sentinel本质上只是一个运行在特殊模式下的Redis服务器,但是因为执行的工作不相同,所以初始化方式也不完全相同.比如:不进行RDB和AOF数据恢复等等.

#### 2). 使用Sentinel专用代码

​		Sentinel使用一些新的代码代替原先的部分Redis代码中,比如默认端口号.使用不同的服务器命令表(因为执行的命令完全不同)

​		这也解释了Sentinel不具备有些Redis服务器的功能.

#### 3). 初始化Sentinel状态

​		服务器会初始化一个sentinelState结构体,也就是Sentinel状态,保存了服务器中所有和Sentinel功能相关的状态.

```c
struct sentinelState{
    // 当前纪元,用于实现故障转移
    uint64_t current_epoch;
    
    // 保存了所有被这个Sentinel监视的主服务器
    // 键是主服务器的名字,值是sentinelRedisInstance结构体指针
    dict *masters;
    
    //是否进入TILT模式
    int tilt;
    
    //目前正在执行的脚本的数量
    int running_scripts;
    
    // 进入TILT模式的时间
    mstime_t tile_start_time;
    
    // 最后一次执行时间处理器的时间
    mstime_t previous_time;
    
    // 一个FIFO队列,包含了所有需要执行的用户脚本
    list *scripts_queue;
};
```

#### 4). 初始化Sentinel状态的masters属性

​		每一个主服务器都对应一个sentinelRedisInstance结构体:

```c
typedef struct sentinelRedisInstance{
    // 标识值,记录当前实例的状态
    int flags;
    
    // 实例的名字
    // 主服务器的名字从配置文件中得到
    // 从服务器和Sentinel的名字由Sentinel自动设置
    // 格式为ip:port
    char *name;
    
    // 实例的运行ID
    char *runid;
    
    // 配置纪元,用于实现故障转移
    uint64_t config_epoch;
    
    // 实例的地址
    sentinelAddr *addr;
    
    //主观下线的判定时间
    mstime_t down_after_period;
    
    // 客观下线的投票数量
    int quorum;
    
    //进行故障转移时,可以同时对新的主服务器进行同步的从服务器的数量
    int parallel_syncs;
    
    // 刷新故障迁移状态的最大时限
    msmtime_t failover_timeout;
    
    // .....
}sentinelRedisInstance;

typedef struct sentinelAddr{
    char *ip;
    int port;
}sentinelAddr;
```

​		Sentinel状态的masters字典的初始化根据载入的配置文件进行.也就是说,配置文件中应该记录所有要监视的主服务器的属性.

#### 5). 创建连向主服务器的网络连接

​		对于每个被监视的主服务器来说,Sentinel会创建两个异步网络连接:

1.  命令连接:用于专门向主服务器发送命令,并接收回复
1.  订阅连接:专门用于订阅主服务器的\_\_sentinel\_\_:hello频道

>   为什么需要订阅连接:
>
>   ​		Redis目前的发布订阅功能,发送的消息不会保存在Redis服务器中,一旦客户端不在线就会丢失,所以只用一个专门的订阅连接来接受该频道的消息.

### (2). 获取主服务器信息

​		Sentinel默认会以每十秒的频率通过命令连接来向被监视的主服务器发送INFO命令,通过分析这个命令的回复来获得对应主服务器的状态.

​		通过INFO命令的回复,Sentinel可以得到以下信息:

1.  关于主服务器本身的信息:服务器运行ID,服务器角色等
1.  关于主服务器属下所有从服务器的信息,每个从服务器由一个"slave"字符串开头的行记录,每一行记录了从服务器的ip和端口

​		根据主服务器本身的信息,Sentinel会对主服务器的实例结构进行更新.而从服务器的信息将被用于更新主服务器实例结构的slaves属性,这个属性记录了下属的所有从服务器字典(键是从服务器名字ip:port,值是从服务器对应的结构),如果从服务器不存在,新建

### (3). 获取从服务器信息

​		当Sentinel发现主服务器有新的从服务器出现时,Sentinel除了会建立对应的实例结构之外,还会创建链接到从服务器的命令连接和订阅连接.也就是说,从服务器和Sentinel也是直接相连的.

​		创建命令连接之后,Sentinel也会每隔十秒型从服务器发送依次INFO命令,获得从服务器的运行id,角色,所连接的主服务器的id和端口,连接状态,从服务器的优先级,复制偏移量.根据这些信息,对从服务器的实例结构进行更新.

### (4). 向主服务器和从服务器发送信息

​		默认情况下,Sentinel会以每两秒一次的频率向所有被连接的主从服务器发送一条命令,这条命令会向服务器的\_\_sentinel\_\_:hello频道发送一条信息,包含一下内容:

| 参数    | 意义           |
| ------- | -------------- |
| s_ip    | Sentinel的ip   |
| s_port  | 端口           |
| s_runid | 运行id         |
| s_epoch | 配置纪元       |
| m_name  | 主服务器的名字 |
| m_ip    | ip             |
| m_port  | 端口           |
| m_rpoch | 当前配置纪元   |

​		如果是从服务器,那么其中的主服务器属性指的是当前进行复制的主服务器的属性.

### (5). 接受来自主服务器和从服务器的频道信息

​		当Sentinel和一个服务器建立订阅连接以后,Sentinel就会通过订阅连接向服务器发送以下命令:

```
SUBSCRIBE __sentinel__:hello
```

​		Sentinel对\_\_sentinel\_\_:hello频道的订阅会一致持续到Sentinel与服务器的连接断开.

​		也就是说,Sentinel不仅仅可以向\_\_sentinel\_\_:hello频道发送消息,也可以从\_\_sentinel\_\_:hello频道读取消息.

​		对于监视同一个服务器的多个Sentinel来说,一个Sentinel发送的消息会被其他Sentinel接收到,这些消息会被用于更新其他Sentinel对于这个服务器的认知.

#### 1). 更新sentinels字典

​		Sentinel为主服务创建的实例结构中的sentinels字典会保存除了自己之外其他连接这个主服务器的Sentinel的资料.这个字典的键是其中一个Sentinel的名字(ip:port),值是对应的Sentinel的实例结构

​		当Sentinel(目标Sentinel)接收到其他Sentinel(源Sentinel)发来的消息时,就会从中得到以下信息:

1.  源Sentinel的ip,端口,运行ID和配置纪元
1.  源Sentinel正在监视的主服务器的名字,ip,端口和配置纪元

​		根据这些消息,Sentinel会主服务器的sentinels字典

#### 2). 创建连向其他Sentinel的命令连接

​		当Sentinel通过频道信息发现一个新的Sentinel是,不仅会更新sentinels字典,还会创建连向这个Sentinel的命令连接.

​		==最终监视同一主服务器的多个Sentinel将形成相互连接的网络.==

### (6). 检测主观下线状态

​		默认情况下,Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例(主服务器,从服务器,其他Sentinel),发送PING命令,名通过实例返回的PING命令回复判断是否在线.

​		返回的回复中处理+PONG,-LOADING,-MASTERDOWN之外都是无效回复.当连续返回无效回复时长达到设定的主观下线时间长度之后,Sentinel就会修改这个实例的实际结构为主观下线.

​		不同的Sentinel可能设置的主观下线时长不同,当一个Sentinel认为某个实例主观下线之后,其他的Sentinel可能认为这个实例是在线的.

### (7). 检查客观下线状态

​		当Sentinel认为某个主服务器主观下线后,为了进行确认,它会向同样监视这个主服务器的其他Sentinel进行询问,当Sentinel从其他Sentinel收集到足够数量的答复(主观下线或者客观下线)能够做出判断之后,Sentinel就会判定主服务器为客观下线,并进行故障转移.

#### 1). 发送SENTINEL is-master-down-by-addr命令

​		该命令的参数:询问是否下线的主服务器的ip,duank,该Sentinel的配置纪元,Sentinel的运行id(这个也可以是\*代替)

#### 2). 接收SENTINEL is-master-down-by-addr命令

​		接收这个命令的Sentinel会提取出其中的各个参数,返回向源Sentinel返回一个回复.回复包含:该主服务器是否下线,局部领头Sentinel的运行id和配置纪元.

#### 3). 接收SENTINEL is-master-down-by-addr,命令的回复

​		源Sentinel接收到所有监视这个主服务器的Sentinel的回复后,就得到了认为该服务器下线的Sentinel的数量,通过和配置指定的判断客观下线的数量进行对比(超过,则下线),就能得出是否客观下线的结论.并对这个主服务器对应结构的标记属性进行修改.

​		注意,客观下线的标准在各个Sentinel中也是不一样的,所以也会出现不同的Sentinel认知不一样的情况.

### (8). 选举领头Sentinel

​		当一个主服务器被认为客观下线时,监视这个主服务器的各个Sentinel会进行协商,选举出一个领头Sentinel,由这和Sentinel对这个下线的主服务器进行故障转移操作.选举的规则和方法:

1.  每个在线的Sentinel都有资格
1.  每次选举,不论是否成功,配置纪元都自增1
1.  在一个配置纪元中(选举之后,自增,一直到下一次自增中间的时间),只有一个Sentinel是领头Sentinel,不可被更改
1.  每个发现主服务器客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel
1.  SENTINEL is-master-down-by-addr命令的参数中运行id不为*,则表示自己要做局部领头Sentinel
1.  局部Sentinel规则先到先得
1.  SENTINEL is-master-down-by-addr命令的回复中有源Sentinel的局部领头Sentinel的运行id和配置纪元,如果配置纪元相同,且运行id是自己,那么就说明发送回复的Sentinel将自己设置成了局部领头
1.  如果一个Sentinel被半数以上的Sentinel设置为局部领头Sentinel,那么它成为领头Sentinel
1.  如果在给定的时间内没有完成选举,那么会重新进行

>   进行选举的SENTINEL is-master-down-by-addr命令和进行客观下线判断的SENTINEL is-master-down-by-addr不重叠.

### (9). 故障转移

​		选举出领头Sentinel后,由这个Sentinel对已经下线的主服务器进行故障转移.包含以下三个步骤:

1.  从这个主服务器的下属中选出一个,升级为主服务器
1.  让其他下属从服务器对这个新的主服务器进行主从连接
1.  将已经下线的主服务器设置为新主服务器的从服务器,当它重新上线时,直接得到身份

#### 1). 选出新的主服务器

​		领头Sentinel会将下线的主服务器的从服务器保存到一个列表中,然后按照以下规则进行过滤:

1.  删除下线或者断线的从服务器
1.  删除5秒内没有回复过领头Sentinel的INFO命令的从服务器
1.  删除与主服务器断开连接超过设定值*10毫秒的从服务器(保证从服务器中的数据较新)

​		然后,按照从服务器的优先级进行选择,选出其中优先级最高的从服务器(相同优先级选择复制偏移量大的,然后进一步选择运行id小的),充当新的主服务器.

#### 2). 修改从服务器的复制目标

​		领头Sentinel向其他所有从服务器发送SLAVEOF命令来让其他的从服务器都与新的主服务器建立主从连接.

#### 3). 将旧的主服务器变为从服务器

​		领头Sentinel还是发送SLAVEOF命令完成这一步.