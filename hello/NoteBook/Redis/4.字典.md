# 第4章 字典

------

[TOC]

-----

>   字典在Redis中的应用非常广泛,Redis中的数据库就是使用字典作为底层实现的(从数据结构的key得到数据结构的对象).
>
>   字典还是哈希类型的底层实现之一,当一个哈希类型包含的键值对比较多,或者键值对中的元素都是比较成的字符串时,Redis就会使用字典作为哈希类型的底层实现.

## 1. 字典的实现

### (1). 哈希表以及其节点的定义

​		Redis字典所使用的哈希表的定义:

```c
// 哈希表节点的定义
typedef struct dictEntry{
    // 键
    void *key;
    // 值(枚举类型,分别存储结构体类型,无符号数和有符号数)
    union{
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;
    // 指向下一个节点
    struct dictEntry *next;
}dictEntry;

// 哈希表整体数据结构的定义
typedef struct dictht{
    // 节点数组(第一个星号表示数组,第二个表示数组中存储的是指向字节节点的指针)
    dictEntry **table;
    // 哈希表的大小
    unsigned long size;
    // 哈希表大小减一,用于方便计算索引值(散列)
    unsigned long sizemask;
    // 已占用的空间数
    unsigned long used;
}
```

​		从以上定义可以看出,Redis中哈希表的底层和Java中HashMap的底层数据结构定义是一样的,嗾使使用数组+链表存储数据,使用链地址法(拉链法)解决哈希冲突.

### (2). 字典

​		Redis中的字典的数据结构定义:

```c
// 这个结构体中定义了一些操纵特定类型键值对的函数,Redis会为不同用途的字典设置不用的函数
// 是为了创建多态字典使用的
typedef struct dictType{
    // 计算哈希值的函数
    unsigned int (*hashFunction)(const void *key);
    // 复制键
    void *(*keyDup)(void *privdata, const void *key);
    // 复制值
    void *(*valDup)(void *privdata, const void *obj);
    // 对比键
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);
    // 销毁键
    void (*keyDestructor)(void *privadata, void *key);
    // 销毁值
    void (*valDestructor)(void *privadata, void *obj);
}
// 这个是字典的结构体定义
typedef struct dict{
    // 这个字典使用的方法
    dictType *type;
    // 私有数据
    void *privdata;
    // 每一个字典都会使用两个哈希表,ht[1]的哈希表只会在ht[0]的哈希表rehash时才会使用
    dictht ht[2];
    // rehash索引,当rehash不再进行时,为-1(相当于状态量,根据这个状态量判断从ht[0]或者ht[1]中取出数据)
    int rehashidx;
}
```

## 2. 哈希算法

​		当要插入键值对时,先要根据插入的键计算出哈希值,然后根据这个哈希值散列到哈希表节点的数组中.

```c
// 每一个字典使用的哈希方法可能是不一样的
hash = dict->type->hashFunction(key);
// 得到哈希值之后,对哈希值和数组长度减一按位与得到数组中的下标
index = hash & dict->ht[x].sizemask;
```

## 3. 解决键冲突

​		Redis中的哈希表使用链地址法解决哈希冲突.

​		因为dictEntry中的链表是单向链表,所以新节点会使用头插法进入链表.

## 4. rehash

Redis中哈希表的rehash机制:

​		二倍对ht[1]扩容(这里保证了容量为2^n,在hash的时候使用了按位与)

​		rehash时全部重新hash到另外一张表中

​		释放原表,然后将新表设置为ht[0],并在ht[1]处创建空白表(这里的空白是指没有初始化数组,但是有其他部分数据)

>   哈希表的扩容和收缩:
>
>   当满足以下条件时,程序自动进行哈希表的扩容:
>
>   1.  服务器没有在执行BGSAVE或者BGREWRITEAOF命令(后台线程持久化数据),并且哈希表的负载因子大于1(负载因子: 元素数 / 桶数量)
>   1.  服务器正在进行后台线程持久化数据,并且负载因子大于5
>
>   另一方面,当负载因子小于0.1时,程序自动进行哈希表的收缩操作.caozuo

## 5. 渐进式rehash

​		rehash动作并不是一次性执行完的,而是分多次,渐进式地完成的.(防止Redis短时间内被rehash占用cpu而停止服务)

​		这个过程是从哈希数组的0号位置向后进行的,rehashidx(rehash索引)表示当前进行到的位置,当rehashidx累加到数组长度时,渐进式rehash结束,设置为-1.

>   渐进式rehash期间对哈希表的操作:
>
>   ​		在渐进式rehash进行时,字典会同时使用两个哈希表,例如:如果要找一个键,会现在ht[0]上面寻找,如果没能找到,再在ht[1]上寻找.
>
>   ​		所有的新值一律会保存到ht[1]中,也就是新表中,保证ht[0]中的数据只减不增.,并且锁着rehash的进行被全部复制到新表中,最后被清空.